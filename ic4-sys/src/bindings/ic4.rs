/*
 * 注意：不要修改此文件。
 * 此文件由bindgen生成，转换自特定的一个或多个C++头文件。详见build.rs文件。
 */
#![allow(unused)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
/* automatically generated by rust-bindgen 0.70.1 */

pub const __bool_true_false_are_defined: i8 = 1;
pub const NULL: i8 = 0;
pub const _VCRT_COMPILER_PREPROCESSOR: i8 = 1;
pub const _SAL_VERSION: i8 = 20;
pub const __SAL_H_VERSION: i32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: i8 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: i8 = 0;
pub const _CRT_PACKING: i8 = 8;
pub const _HAS_EXCEPTIONS: i8 = 1;
pub const _HAS_CXX17: i8 = 0;
pub const _HAS_CXX20: i8 = 0;
pub const _HAS_CXX23: i8 = 0;
pub const _HAS_NODISCARD: i8 = 1;
pub const WCHAR_MIN: i8 = 0;
pub const WCHAR_MAX: i32 = 65535;
pub const WINT_MIN: i8 = 0;
pub const WINT_MAX: i32 = 65535;
pub const IC4_WINDOW_HANDLE_NULL: i8 = 0;
pub const IC4_PROPID_ACQUISITION_BURST_FRAME_COUNT: &[u8; 27] = b"AcquisitionBurstFrameCount\0";
pub const IC4_PROPID_ACQUISITION_BURST_INTERVAL: &[u8; 25] = b"AcquisitionBurstInterval\0";
pub const IC4_PROPID_ACQUISITION_FRAME_RATE: &[u8; 21] = b"AcquisitionFrameRate\0";
pub const IC4_PROPID_ACQUISITION_MODE: &[u8; 16] = b"AcquisitionMode\0";
pub const IC4_PROPID_ACQUISITION_START: &[u8; 17] = b"AcquisitionStart\0";
pub const IC4_PROPID_ACQUISITION_STOP: &[u8; 16] = b"AcquisitionStop\0";
pub const IC4_PROPID_ACTION_DEVICE_KEY: &[u8; 16] = b"ActionDeviceKey\0";
pub const IC4_PROPID_ACTION_GROUP_KEY: &[u8; 15] = b"ActionGroupKey\0";
pub const IC4_PROPID_ACTION_GROUP_MASK: &[u8; 16] = b"ActionGroupMask\0";
pub const IC4_PROPID_ACTION_QUEUE_SIZE: &[u8; 16] = b"ActionQueueSize\0";
pub const IC4_PROPID_ACTION_SCHEDULER_CANCEL: &[u8; 22] = b"ActionSchedulerCancel\0";
pub const IC4_PROPID_ACTION_SCHEDULER_COMMIT: &[u8; 22] = b"ActionSchedulerCommit\0";
pub const IC4_PROPID_ACTION_SCHEDULER_INTERVAL: &[u8; 24] = b"ActionSchedulerInterval\0";
pub const IC4_PROPID_ACTION_SCHEDULER_STATUS: &[u8; 22] = b"ActionSchedulerStatus\0";
pub const IC4_PROPID_ACTION_SCHEDULER_TIME: &[u8; 20] = b"ActionSchedulerTime\0";
pub const IC4_PROPID_ACTION_SELECTOR: &[u8; 15] = b"ActionSelector\0";
pub const IC4_PROPID_AUTO_FOCUS_ROI_ENABLE: &[u8; 19] = b"AutoFocusROIEnable\0";
pub const IC4_PROPID_AUTO_FOCUS_ROI_HEIGHT: &[u8; 19] = b"AutoFocusROIHeight\0";
pub const IC4_PROPID_AUTO_FOCUS_ROI_LEFT: &[u8; 17] = b"AutoFocusROILeft\0";
pub const IC4_PROPID_AUTO_FOCUS_ROI_TOP: &[u8; 16] = b"AutoFocusROITop\0";
pub const IC4_PROPID_AUTO_FOCUS_ROI_WIDTH: &[u8; 18] = b"AutoFocusROIWidth\0";
pub const IC4_PROPID_AUTO_FUNCTIONS_ROI_ENABLE: &[u8; 23] = b"AutoFunctionsROIEnable\0";
pub const IC4_PROPID_AUTO_FUNCTIONS_ROI_HEIGHT: &[u8; 23] = b"AutoFunctionsROIHeight\0";
pub const IC4_PROPID_AUTO_FUNCTIONS_ROI_LEFT: &[u8; 21] = b"AutoFunctionsROILeft\0";
pub const IC4_PROPID_AUTO_FUNCTIONS_ROI_PRESET: &[u8; 23] = b"AutoFunctionsROIPreset\0";
pub const IC4_PROPID_AUTO_FUNCTIONS_ROI_TOP: &[u8; 20] = b"AutoFunctionsROITop\0";
pub const IC4_PROPID_AUTO_FUNCTIONS_ROI_WIDTH: &[u8; 22] = b"AutoFunctionsROIWidth\0";
pub const IC4_PROPID_BALANCE_RATIO: &[u8; 13] = b"BalanceRatio\0";
pub const IC4_PROPID_BALANCE_RATIO_SELECTOR: &[u8; 21] = b"BalanceRatioSelector\0";
pub const IC4_PROPID_BALANCE_WHITE_AUTO: &[u8; 17] = b"BalanceWhiteAuto\0";
pub const IC4_PROPID_BALANCE_WHITE_AUTO_PRESET: &[u8; 23] = b"BalanceWhiteAutoPreset\0";
pub const IC4_PROPID_BALANCE_WHITE_MODE: &[u8; 17] = b"BalanceWhiteMode\0";
pub const IC4_PROPID_BALANCE_WHITE_TEMPERATURE: &[u8; 24] = b"BalanceWhiteTemperature\0";
pub const IC4_PROPID_BALANCE_WHITE_TEMPERATURE_PRESET: &[u8; 30] =
    b"BalanceWhiteTemperaturePreset\0";
pub const IC4_PROPID_BINNING_HORIZONTAL: &[u8; 18] = b"BinningHorizontal\0";
pub const IC4_PROPID_BINNING_VERTICAL: &[u8; 16] = b"BinningVertical\0";
pub const IC4_PROPID_BLACK_LEVEL: &[u8; 11] = b"BlackLevel\0";
pub const IC4_PROPID_CHUNK_BLOCK_ID: &[u8; 13] = b"ChunkBlockId\0";
pub const IC4_PROPID_CHUNK_ENABLE: &[u8; 12] = b"ChunkEnable\0";
pub const IC4_PROPID_CHUNK_EXPOSURE_TIME: &[u8; 18] = b"ChunkExposureTime\0";
pub const IC4_PROPID_CHUNK_GAIN: &[u8; 10] = b"ChunkGain\0";
pub const IC4_PROPID_CHUNK_IMAGE: &[u8; 11] = b"ChunkImage\0";
pub const IC4_PROPID_CHUNK_IMX174_FRAME_ID: &[u8; 19] = b"ChunkIMX174FrameId\0";
pub const IC4_PROPID_CHUNK_IMX174_FRAME_SET: &[u8; 20] = b"ChunkIMX174FrameSet\0";
pub const IC4_PROPID_CHUNK_MODE_ACTIVE: &[u8; 16] = b"ChunkModeActive\0";
pub const IC4_PROPID_CHUNK_MULTI_FRAME_SET_FRAME_ID: &[u8; 26] = b"ChunkMultiFrameSetFrameId\0";
pub const IC4_PROPID_CHUNK_MULTI_FRAME_SET_ID: &[u8; 21] = b"ChunkMultiFrameSetId\0";
pub const IC4_PROPID_CHUNK_SELECTOR: &[u8; 14] = b"ChunkSelector\0";
pub const IC4_PROPID_COLOR_TRANSFORMATION_ENABLE: &[u8; 26] = b"ColorTransformationEnable\0";
pub const IC4_PROPID_COLOR_TRANSFORMATION_SELECTOR: &[u8; 28] = b"ColorTransformationSelector\0";
pub const IC4_PROPID_COLOR_TRANSFORMATION_VALUE: &[u8; 25] = b"ColorTransformationValue\0";
pub const IC4_PROPID_COLOR_TRANSFORMATION_VALUE_SELECTOR: &[u8; 33] =
    b"ColorTransformationValueSelector\0";
pub const IC4_PROPID_CONTRAST: &[u8; 9] = b"Contrast\0";
pub const IC4_PROPID_DECIMATION_HORIZONTAL: &[u8; 21] = b"DecimationHorizontal\0";
pub const IC4_PROPID_DECIMATION_VERTICAL: &[u8; 19] = b"DecimationVertical\0";
pub const IC4_PROPID_DENOISE: &[u8; 8] = b"Denoise\0";
pub const IC4_PROPID_DEVICE_EVENT_CHANNEL_COUNT: &[u8; 24] = b"DeviceEventChannelCount\0";
pub const IC4_PROPID_DEVICE_FACTORY_RESET: &[u8; 19] = b"DeviceFactoryReset\0";
pub const IC4_PROPID_DEVICE_FIRMWARE_VERSION: &[u8; 22] = b"DeviceFirmwareVersion\0";
pub const IC4_PROPID_DEVICE_LINK_HEARTBEAT_TIMEOUT: &[u8; 27] = b"DeviceLinkHeartbeatTimeout\0";
pub const IC4_PROPID_DEVICE_LINK_SELECTOR: &[u8; 19] = b"DeviceLinkSelector\0";
pub const IC4_PROPID_DEVICE_MODEL_NAME: &[u8; 16] = b"DeviceModelName\0";
pub const IC4_PROPID_DEVICE_RESET: &[u8; 12] = b"DeviceReset\0";
pub const IC4_PROPID_DEVICE_SCAN_TYPE: &[u8; 15] = b"DeviceScanType\0";
pub const IC4_PROPID_DEVICE_SERIAL_NUMBER: &[u8; 19] = b"DeviceSerialNumber\0";
pub const IC4_PROPID_DEVICE_SFNC_VERSION_MAJOR: &[u8; 23] = b"DeviceSFNCVersionMajor\0";
pub const IC4_PROPID_DEVICE_SFNC_VERSION_MINOR: &[u8; 23] = b"DeviceSFNCVersionMinor\0";
pub const IC4_PROPID_DEVICE_SFNC_VERSION_SUB_MINOR: &[u8; 26] = b"DeviceSFNCVersionSubMinor\0";
pub const IC4_PROPID_DEVICE_STREAM_CHANNEL_COUNT: &[u8; 25] = b"DeviceStreamChannelCount\0";
pub const IC4_PROPID_DEVICE_STREAM_CHANNEL_ENDIANNESS: &[u8; 30] =
    b"DeviceStreamChannelEndianness\0";
pub const IC4_PROPID_DEVICE_STREAM_CHANNEL_LINK: &[u8; 24] = b"DeviceStreamChannelLink\0";
pub const IC4_PROPID_DEVICE_STREAM_CHANNEL_PACKET_SIZE: &[u8; 30] =
    b"DeviceStreamChannelPacketSize\0";
pub const IC4_PROPID_DEVICE_STREAM_CHANNEL_SELECTOR: &[u8; 28] = b"DeviceStreamChannelSelector\0";
pub const IC4_PROPID_DEVICE_STREAM_CHANNEL_TYPE: &[u8; 24] = b"DeviceStreamChannelType\0";
pub const IC4_PROPID_DEVICE_TEMPERATURE: &[u8; 18] = b"DeviceTemperature\0";
pub const IC4_PROPID_DEVICE_TEMPERATURE_SELECTOR: &[u8; 26] = b"DeviceTemperatureSelector\0";
pub const IC4_PROPID_DEVICE_TL_TYPE: &[u8; 13] = b"DeviceTLType\0";
pub const IC4_PROPID_DEVICE_TL_VERSION_MAJOR: &[u8; 21] = b"DeviceTLVersionMajor\0";
pub const IC4_PROPID_DEVICE_TL_VERSION_MINOR: &[u8; 21] = b"DeviceTLVersionMinor\0";
pub const IC4_PROPID_DEVICE_TL_VERSION_SUB_MINOR: &[u8; 24] = b"DeviceTLVersionSubMinor\0";
pub const IC4_PROPID_DEVICE_TYPE: &[u8; 11] = b"DeviceType\0";
pub const IC4_PROPID_DEVICE_USER_ID: &[u8; 13] = b"DeviceUserID\0";
pub const IC4_PROPID_DEVICE_VENDOR_NAME: &[u8; 17] = b"DeviceVendorName\0";
pub const IC4_PROPID_DEVICE_VERSION: &[u8; 14] = b"DeviceVersion\0";
pub const IC4_PROPID_DISABLE_INFO_OVERLAY: &[u8; 19] = b"DisableInfoOverlay\0";
pub const IC4_PROPID_EVENT_EXPOSURE_END: &[u8; 17] = b"EventExposureEnd\0";
pub const IC4_PROPID_EVENT_EXPOSURE_END_FRAME_ID: &[u8; 24] = b"EventExposureEndFrameID\0";
pub const IC4_PROPID_EVENT_EXPOSURE_END_TIMESTAMP: &[u8; 26] = b"EventExposureEndTimestamp\0";
pub const IC4_PROPID_EVENT_FOCUS_MOVE_COMPLETED: &[u8; 24] = b"EventFocusMoveCompleted\0";
pub const IC4_PROPID_EVENT_FOCUS_MOVE_COMPLETED_FOCUS: &[u8; 29] =
    b"EventFocusMoveCompletedFocus\0";
pub const IC4_PROPID_EVENT_FOCUS_MOVE_COMPLETED_TIMESTAMP: &[u8; 33] =
    b"EventFocusMoveCompletedTimestamp\0";
pub const IC4_PROPID_EVENT_FRAME_TRIGGER_MISSED: &[u8; 24] = b"EventFrameTriggerMissed\0";
pub const IC4_PROPID_EVENT_FRAME_TRIGGER_MISSED_TIMESTAMP: &[u8; 33] =
    b"EventFrameTriggerMissedTimestamp\0";
pub const IC4_PROPID_EVENT_LINE1_FALLING_EDGE: &[u8; 22] = b"EventLine1FallingEdge\0";
pub const IC4_PROPID_EVENT_LINE1_FALLING_EDGE_TIMESTAMP: &[u8; 31] =
    b"EventLine1FallingEdgeTimestamp\0";
pub const IC4_PROPID_EVENT_LINE1_RISING_EDGE: &[u8; 21] = b"EventLine1RisingEdge\0";
pub const IC4_PROPID_EVENT_LINE1_RISING_EDGE_TIMESTAMP: &[u8; 30] =
    b"EventLine1RisingEdgeTimestamp\0";
pub const IC4_PROPID_EVENT_NOTIFICATION: &[u8; 18] = b"EventNotification\0";
pub const IC4_PROPID_EVENT_SELECTOR: &[u8; 14] = b"EventSelector\0";
pub const IC4_PROPID_EVENT_TEST: &[u8; 10] = b"EventTest\0";
pub const IC4_PROPID_EVENT_TEST_TIMESTAMP: &[u8; 19] = b"EventTestTimestamp\0";
pub const IC4_PROPID_EVENT_ZOOM_MOVE_COMPLETED: &[u8; 23] = b"EventZoomMoveCompleted\0";
pub const IC4_PROPID_EVENT_ZOOM_MOVE_COMPLETED_TIMESTAMP: &[u8; 32] =
    b"EventZoomMoveCompletedTimestamp\0";
pub const IC4_PROPID_EVENT_ZOOM_MOVE_COMPLETED_ZOOM: &[u8; 27] = b"EventZoomMoveCompletedZoom\0";
pub const IC4_PROPID_EXPAND_OUTPUT_RANGE: &[u8; 18] = b"ExpandOutputRange\0";
pub const IC4_PROPID_EXPOSURE_AUTO: &[u8; 13] = b"ExposureAuto\0";
pub const IC4_PROPID_EXPOSURE_AUTO_HIGHLIGH_REDUCTION: &[u8; 30] =
    b"ExposureAutoHighlighReduction\0";
pub const IC4_PROPID_EXPOSURE_AUTO_HIGHLIGHT_REDUCTION: &[u8; 31] =
    b"ExposureAutoHighlightReduction\0";
pub const IC4_PROPID_EXPOSURE_AUTO_LOWER_LIMIT: &[u8; 23] = b"ExposureAutoLowerLimit\0";
pub const IC4_PROPID_EXPOSURE_AUTO_REFERENCE: &[u8; 22] = b"ExposureAutoReference\0";
pub const IC4_PROPID_EXPOSURE_AUTO_UPPER_LIMIT: &[u8; 23] = b"ExposureAutoUpperLimit\0";
pub const IC4_PROPID_EXPOSURE_AUTO_UPPER_LIMIT_AUTO: &[u8; 27] = b"ExposureAutoUpperLimitAuto\0";
pub const IC4_PROPID_EXPOSURE_TIME: &[u8; 13] = b"ExposureTime\0";
pub const IC4_PROPID_FILE_ACCESS_BUFFER: &[u8; 17] = b"FileAccessBuffer\0";
pub const IC4_PROPID_FILE_ACCESS_LENGTH: &[u8; 17] = b"FileAccessLength\0";
pub const IC4_PROPID_FILE_ACCESS_OFFSET: &[u8; 17] = b"FileAccessOffset\0";
pub const IC4_PROPID_FILE_OPEN_MODE: &[u8; 13] = b"FileOpenMode\0";
pub const IC4_PROPID_FILE_OPERATION_EXECUTE: &[u8; 21] = b"FileOperationExecute\0";
pub const IC4_PROPID_FILE_OPERATION_RESULT: &[u8; 20] = b"FileOperationResult\0";
pub const IC4_PROPID_FILE_OPERATION_SELECTOR: &[u8; 22] = b"FileOperationSelector\0";
pub const IC4_PROPID_FILE_OPERATION_STATUS: &[u8; 20] = b"FileOperationStatus\0";
pub const IC4_PROPID_FILE_SELECTOR: &[u8; 13] = b"FileSelector\0";
pub const IC4_PROPID_FILE_SIZE: &[u8; 9] = b"FileSize\0";
pub const IC4_PROPID_FOCUS: &[u8; 6] = b"Focus\0";
pub const IC4_PROPID_FOCUS_AUTO: &[u8; 10] = b"FocusAuto\0";
pub const IC4_PROPID_GAIN: &[u8; 5] = b"Gain\0";
pub const IC4_PROPID_GAIN_AUTO: &[u8; 9] = b"GainAuto\0";
pub const IC4_PROPID_GAIN_AUTO_LOWER_LIMIT: &[u8; 19] = b"GainAutoLowerLimit\0";
pub const IC4_PROPID_GAIN_AUTO_UPPER_LIMIT: &[u8; 19] = b"GainAutoUpperLimit\0";
pub const IC4_PROPID_GAIN_MODE: &[u8; 9] = b"GainMode\0";
pub const IC4_PROPID_GAMMA: &[u8; 6] = b"Gamma\0";
pub const IC4_PROPID_GEV_GVSP_EXTENDED_ID_MODE: &[u8; 22] = b"GevGVSPExtendedIDMode\0";
pub const IC4_PROPID_GEV_SCPS_DO_NOT_FRAGMENT: &[u8; 21] = b"GevSCPSDoNotFragment\0";
pub const IC4_PROPID_GEV_SCPS_PACKET_SIZE: &[u8; 18] = b"GevSCPSPacketSize\0";
pub const IC4_PROPID_GP_IN: &[u8; 5] = b"GPIn\0";
pub const IC4_PROPID_GP_OUT: &[u8; 6] = b"GPOut\0";
pub const IC4_PROPID_HEIGHT: &[u8; 7] = b"Height\0";
pub const IC4_PROPID_HEIGHT_MAX: &[u8; 10] = b"HeightMax\0";
pub const IC4_PROPID_HUE: &[u8; 4] = b"Hue\0";
pub const IC4_PROPID_IMX174_HARDWARE_WDR_ENABLE: &[u8; 24] = b"IMX174HardwareWDREnable\0";
pub const IC4_PROPID_IMX174_HARDWARE_WDR_SHUTTER_MODE: &[u8; 29] =
    b"IMX174HardwareWDRShutterMode\0";
pub const IC4_PROPID_IMX174_WDR_SHUTTER2: &[u8; 18] = b"IMX174WDRShutter2\0";
pub const IC4_PROPID_IMX_LOW_LATENCY_TRIGGER_MODE: &[u8; 25] = b"IMXLowLatencyTriggerMode\0";
pub const IC4_PROPID_INPUT_BITS: &[u8; 10] = b"InputBits\0";
pub const IC4_PROPID_INPUT_FP1KS: &[u8; 11] = b"InputFp1ks\0";
pub const IC4_PROPID_INPUT_HEIGHT: &[u8; 12] = b"InputHeight\0";
pub const IC4_PROPID_INPUT_WIDTH: &[u8; 11] = b"InputWidth\0";
pub const IC4_PROPID_IR_CUT_FILTER_ENABLE: &[u8; 18] = b"IRCutFilterEnable\0";
pub const IC4_PROPID_IRIS: &[u8; 5] = b"Iris\0";
pub const IC4_PROPID_IRIS_AUTO: &[u8; 9] = b"IrisAuto\0";
pub const IC4_PROPID_LUT_ENABLE: &[u8; 10] = b"LUTEnable\0";
pub const IC4_PROPID_LUT_INDEX: &[u8; 9] = b"LUTIndex\0";
pub const IC4_PROPID_LUT_SELECTOR: &[u8; 12] = b"LUTSelector\0";
pub const IC4_PROPID_LUT_VALUE: &[u8; 9] = b"LUTValue\0";
pub const IC4_PROPID_LUT_VALUE_ALL: &[u8; 12] = b"LUTValueAll\0";
pub const IC4_PROPID_MULTI_FRAME_SET_OUTPUT_MODE_CUSTOM_GAIN: &[u8; 34] =
    b"MultiFrameSetOutputModeCustomGain\0";
pub const IC4_PROPID_MULTI_FRAME_SET_OUTPUT_MODE_ENABLE: &[u8; 30] =
    b"MultiFrameSetOutputModeEnable\0";
pub const IC4_PROPID_MULTI_FRAME_SET_OUTPUT_MODE_EXPOSURE_TIME0: &[u8; 37] =
    b"MultiFrameSetOutputModeExposureTime0\0";
pub const IC4_PROPID_MULTI_FRAME_SET_OUTPUT_MODE_EXPOSURE_TIME1: &[u8; 37] =
    b"MultiFrameSetOutputModeExposureTime1\0";
pub const IC4_PROPID_MULTI_FRAME_SET_OUTPUT_MODE_EXPOSURE_TIME2: &[u8; 37] =
    b"MultiFrameSetOutputModeExposureTime2\0";
pub const IC4_PROPID_MULTI_FRAME_SET_OUTPUT_MODE_EXPOSURE_TIME3: &[u8; 37] =
    b"MultiFrameSetOutputModeExposureTime3\0";
pub const IC4_PROPID_MULTI_FRAME_SET_OUTPUT_MODE_FRAME_COUNT: &[u8; 34] =
    b"MultiFrameSetOutputModeFrameCount\0";
pub const IC4_PROPID_MULTI_FRAME_SET_OUTPUT_MODE_GAIN0: &[u8; 29] =
    b"MultiFrameSetOutputModeGain0\0";
pub const IC4_PROPID_MULTI_FRAME_SET_OUTPUT_MODE_GAIN1: &[u8; 29] =
    b"MultiFrameSetOutputModeGain1\0";
pub const IC4_PROPID_MULTI_FRAME_SET_OUTPUT_MODE_GAIN2: &[u8; 29] =
    b"MultiFrameSetOutputModeGain2\0";
pub const IC4_PROPID_MULTI_FRAME_SET_OUTPUT_MODE_GAIN3: &[u8; 29] =
    b"MultiFrameSetOutputModeGain3\0";
pub const IC4_PROPID_OFFSET_AUTO_CENTER: &[u8; 17] = b"OffsetAutoCenter\0";
pub const IC4_PROPID_OFFSET_X: &[u8; 8] = b"OffsetX\0";
pub const IC4_PROPID_OFFSET_Y: &[u8; 8] = b"OffsetY\0";
pub const IC4_PROPID_PAYLOAD_SIZE: &[u8; 12] = b"PayloadSize\0";
pub const IC4_PROPID_PIXEL_FORMAT: &[u8; 12] = b"PixelFormat\0";
pub const IC4_PROPID_PTP_CLOCK_ACCURACY: &[u8; 17] = b"PtpClockAccuracy\0";
pub const IC4_PROPID_PTP_ENABLE: &[u8; 10] = b"PtpEnable\0";
pub const IC4_PROPID_PTP_STATUS: &[u8; 10] = b"PtpStatus\0";
pub const IC4_PROPID_REVERSE_X: &[u8; 9] = b"ReverseX\0";
pub const IC4_PROPID_REVERSE_Y: &[u8; 9] = b"ReverseY\0";
pub const IC4_PROPID_SATURATION: &[u8; 11] = b"Saturation\0";
pub const IC4_PROPID_SENSOR_HEIGHT: &[u8; 13] = b"SensorHeight\0";
pub const IC4_PROPID_SENSOR_PIXEL_HEIGHT: &[u8; 18] = b"SensorPixelHeight\0";
pub const IC4_PROPID_SENSOR_PIXEL_WIDTH: &[u8; 17] = b"SensorPixelWidth\0";
pub const IC4_PROPID_SENSOR_WIDTH: &[u8; 12] = b"SensorWidth\0";
pub const IC4_PROPID_SHARPNESS: &[u8; 10] = b"Sharpness\0";
pub const IC4_PROPID_SIDEBAND_USE: &[u8; 12] = b"SidebandUse\0";
pub const IC4_PROPID_SIGNAL_DETECTED: &[u8; 15] = b"SignalDetected\0";
pub const IC4_PROPID_SOFTWARE_TRANSFORM_ENABLE: &[u8; 24] = b"SoftwareTransformEnable\0";
pub const IC4_PROPID_SOURCE_CONNECTED: &[u8; 16] = b"SourceConnected\0";
pub const IC4_PROPID_STROBE_DELAY: &[u8; 12] = b"StrobeDelay\0";
pub const IC4_PROPID_STROBE_DURATION: &[u8; 15] = b"StrobeDuration\0";
pub const IC4_PROPID_STROBE_ENABLE: &[u8; 13] = b"StrobeEnable\0";
pub const IC4_PROPID_STROBE_OPERATION: &[u8; 16] = b"StrobeOperation\0";
pub const IC4_PROPID_STROBE_POLARITY: &[u8; 15] = b"StrobePolarity\0";
pub const IC4_PROPID_TEST_EVENT_GENERATE: &[u8; 18] = b"TestEventGenerate\0";
pub const IC4_PROPID_TEST_PENDING_ACK: &[u8; 15] = b"TestPendingAck\0";
pub const IC4_PROPID_TIMESTAMP_LATCH: &[u8; 15] = b"TimestampLatch\0";
pub const IC4_PROPID_TIMESTAMP_LATCH_STRING: &[u8; 21] = b"TimestampLatchString\0";
pub const IC4_PROPID_TIMESTAMP_LATCH_VALUE: &[u8; 20] = b"TimestampLatchValue\0";
pub const IC4_PROPID_TIMESTAMP_RESET: &[u8; 15] = b"TimestampReset\0";
pub const IC4_PROPID_TL_PARAMS_LOCKED: &[u8; 15] = b"TLParamsLocked\0";
pub const IC4_PROPID_TONE_MAPPING_ENABLE: &[u8; 18] = b"ToneMappingEnable\0";
pub const IC4_PROPID_TONE_MAPPING_GLOBAL_BRIGHTNESS: &[u8; 28] = b"ToneMappingGlobalBrightness\0";
pub const IC4_PROPID_TONE_MAPPING_INTENSITY: &[u8; 21] = b"ToneMappingIntensity\0";
pub const IC4_PROPID_TRIGGER_ACTIVATION: &[u8; 18] = b"TriggerActivation\0";
pub const IC4_PROPID_TRIGGER_DEBOUNCER: &[u8; 17] = b"TriggerDebouncer\0";
pub const IC4_PROPID_TRIGGER_DELAY: &[u8; 13] = b"TriggerDelay\0";
pub const IC4_PROPID_TRIGGER_DENOISE: &[u8; 15] = b"TriggerDenoise\0";
pub const IC4_PROPID_TRIGGER_MASK: &[u8; 12] = b"TriggerMask\0";
pub const IC4_PROPID_TRIGGER_MODE: &[u8; 12] = b"TriggerMode\0";
pub const IC4_PROPID_TRIGGER_OPERATION: &[u8; 17] = b"TriggerOperation\0";
pub const IC4_PROPID_TRIGGER_OVERLAP: &[u8; 15] = b"TriggerOverlap\0";
pub const IC4_PROPID_TRIGGER_SELECTOR: &[u8; 16] = b"TriggerSelector\0";
pub const IC4_PROPID_TRIGGER_SOFTWARE: &[u8; 16] = b"TriggerSoftware\0";
pub const IC4_PROPID_TRIGGER_SOURCE: &[u8; 14] = b"TriggerSource\0";
pub const IC4_PROPID_USER_SET_DEFAULT: &[u8; 15] = b"UserSetDefault\0";
pub const IC4_PROPID_USER_SET_LOAD: &[u8; 12] = b"UserSetLoad\0";
pub const IC4_PROPID_USER_SET_SAVE: &[u8; 12] = b"UserSetSave\0";
pub const IC4_PROPID_USER_SET_SELECTOR: &[u8; 16] = b"UserSetSelector\0";
pub const IC4_PROPID_WIDTH: &[u8; 6] = b"Width\0";
pub const IC4_PROPID_WIDTH_MAX: &[u8; 9] = b"WidthMax\0";
pub const IC4_PROPID_ZOOM: &[u8; 5] = b"Zoom\0";
pub type std_nullptr_t = *const ::std::os::raw::c_void;
pub type max_align_t = f64;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut va_list, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __vcrt_va_list_is_reference {
    pub _address: u8,
}
pub const __vcrt_va_list_is_reference___the_value: __vcrt_va_list_is_reference__bindgen_ty_1 =
    __vcrt_va_list_is_reference__bindgen_ty_1::__the_value;
#[repr(u8)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum __vcrt_va_list_is_reference__bindgen_ty_1 {
    __the_value = 0,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __vcrt_assert_va_start_is_not_reference {
    pub _address: u8,
}
pub type __vcrt_bool = bool;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[repr(i32)]
#[non_exhaustive]
#[doc = " The pixel format defines the representation of pixels in an image."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IC4_PIXEL_FORMAT {
    #[doc = "< Unspecified pixel format, used to partially define a image type"]
    IC4_PIXEL_FORMAT_Unspecified = 0,
    #[doc = "< Monochrome 8-bit"]
    IC4_PIXEL_FORMAT_Mono8 = 17301505,
    #[doc = "< Monochrome 10-bit packed"]
    IC4_PIXEL_FORMAT_Mono10p = 17432646,
    #[doc = "< Monochrome 12-bit packed"]
    IC4_PIXEL_FORMAT_Mono12p = 17563719,
    #[doc = "< Monochrome 16-bit"]
    IC4_PIXEL_FORMAT_Mono16 = 17825799,
    #[doc = "< Bayer Blue-Green 8-bit"]
    IC4_PIXEL_FORMAT_BayerBG8 = 17301515,
    #[doc = "< Bayer Blue-Green 10-bit packed"]
    IC4_PIXEL_FORMAT_BayerBG10p = 17432658,
    #[doc = "< Bayer Blue-Green 12-bit packed"]
    IC4_PIXEL_FORMAT_BayerBG12p = 17563731,
    #[doc = "< Bayer Blue-Green 16-bit"]
    IC4_PIXEL_FORMAT_BayerBG16 = 17825841,
    #[doc = "< Bayer Green-Blue 8-bit"]
    IC4_PIXEL_FORMAT_BayerGB8 = 17301514,
    #[doc = "< Bayer Green-Blue 10-bit packed"]
    IC4_PIXEL_FORMAT_BayerGB10p = 17432660,
    #[doc = "< Bayer Green-Blue 12-bit packed"]
    IC4_PIXEL_FORMAT_BayerGB12p = 17563733,
    #[doc = "< Bayer Green-Blue 16-bit"]
    IC4_PIXEL_FORMAT_BayerGB16 = 17825840,
    #[doc = "< Bayer Green-Red 8-bit"]
    IC4_PIXEL_FORMAT_BayerGR8 = 17301512,
    #[doc = "< Bayer Green-Red 10-bit packed"]
    IC4_PIXEL_FORMAT_BayerGR10p = 17432662,
    #[doc = "< Bayer Green-Red 12-bit packed"]
    IC4_PIXEL_FORMAT_BayerGR12p = 17563735,
    #[doc = "< Bayer Green-Red 16-bit"]
    IC4_PIXEL_FORMAT_BayerGR16 = 17825838,
    #[doc = "< Bayer Red-Green 8-bit"]
    IC4_PIXEL_FORMAT_BayerRG8 = 17301513,
    #[doc = "< Bayer Red-Green 10-bit packed"]
    IC4_PIXEL_FORMAT_BayerRG10p = 17432664,
    #[doc = "< Bayer Red-Green 12-bit packed"]
    IC4_PIXEL_FORMAT_BayerRG12p = 17563737,
    #[doc = "< Bayer Red-Green 16-bit"]
    IC4_PIXEL_FORMAT_BayerRG16 = 17825839,
    #[doc = "< Blue-Green-Red-alpha 8-bit"]
    IC4_PIXEL_FORMAT_BGRa8 = 35651607,
    #[doc = "< Blue-Green-Red-alpha 16-bit"]
    IC4_PIXEL_FORMAT_BGRa16 = 37748817,
    #[doc = "< Blue-Green-Red 8-bit"]
    IC4_PIXEL_FORMAT_BGR8 = 35127317,
    #[doc = "< GigE Vision specific format, Monochrome 12-bit packed"]
    IC4_PIXEL_FORMAT_Mono12Packed = 17563654,
    #[doc = "< GigE Vision specific format, Bayer Blue-Green 12-bit packed"]
    IC4_PIXEL_FORMAT_BayerBG12Packed = 17563693,
    #[doc = "< GigE Vision specific format, Bayer Green-Blue 12-bit packed"]
    IC4_PIXEL_FORMAT_BayerGB12Packed = 17563692,
    #[doc = "< GigE Vision specific format, Bayer Green-Red 12-bit packed"]
    IC4_PIXEL_FORMAT_BayerGR12Packed = 17563690,
    #[doc = "< GigE Vision specific format, Bayer Red-Green 12-bit packed"]
    IC4_PIXEL_FORMAT_BayerRG12Packed = 17563691,
    #[doc = "< YUV 4:2:2 8-bit"]
    IC4_PIXEL_FORMAT_YUV422_8 = 34603058,
    #[doc = "< YCbCr 4:2:2 8-bit"]
    IC4_PIXEL_FORMAT_YCbCr422_8 = 34603067,
    #[doc = "< YCbCr 4:1:1 8-bit (CbYYCrYY)"]
    IC4_PIXEL_FORMAT_YCbCr411_8_CbYYCrYY = 34340924,
    #[doc = "< YCbCr 4:1:1 8-bit (YYCbYYCr)"]
    IC4_PIXEL_FORMAT_YCbCr411_8 = 34340954,
    #[doc = " @brief Virtual pixel format value to select any 8-bit bayer format\n\n When setting the camera's @ref IC4_PROPID_PIXEL_FORMAT to this value, automatically selects one of the 8-bit bayer pixel formats\n @ref IC4_PIXEL_FORMAT_BayerBG8, @ref IC4_PIXEL_FORMAT_BayerGB8, @ref IC4_PIXEL_FORMAT_BayerRG8 or @ref IC4_PIXEL_FORMAT_BayerGR8."]
    IC4_PIXEL_FORMAT_AnyBayer8 = -2130116863,
    #[doc = " @brief Virtual pixel format value to select any 10-bit packed bayer format\n\n When setting the camera's @ref IC4_PROPID_PIXEL_FORMAT to this value, automatically selects one of the 10-bit packed bayer pixel formats\n @ref IC4_PIXEL_FORMAT_BayerBG10p, @ref IC4_PIXEL_FORMAT_BayerGB10p, @ref IC4_PIXEL_FORMAT_BayerRG10p or @ref IC4_PIXEL_FORMAT_BayerGR10p."]
    IC4_PIXEL_FORMAT_AnyBayer10p = -2129985791,
    #[doc = " @brief Virtual pixel format value to select any 12-bit packed bayer format\n\n When setting the camera's @ref IC4_PROPID_PIXEL_FORMAT to this value, automatically selects one of the 12-bit packed bayer pixel formats\n @ref IC4_PIXEL_FORMAT_BayerBG12p, @ref IC4_PIXEL_FORMAT_BayerGB12p, @ref IC4_PIXEL_FORMAT_BayerRG12p, @ref IC4_PIXEL_FORMAT_BayerGR12p,\n @ref IC4_PIXEL_FORMAT_BayerBG12Packed, @ref IC4_PIXEL_FORMAT_BayerGB12Packed, @ref IC4_PIXEL_FORMAT_BayerRG12Packed or @ref IC4_PIXEL_FORMAT_BayerGR12Packed."]
    IC4_PIXEL_FORMAT_AnyBayer12p = -2129854719,
    #[doc = " @brief Virtual pixel format value to select any 16-bit bayer format\n\n When setting the camera's @ref IC4_PROPID_PIXEL_FORMAT to this value, automatically selects one of the 16-bit bayer pixel formats\n @ref IC4_PIXEL_FORMAT_BayerBG16, @ref IC4_PIXEL_FORMAT_BayerGB16, @ref IC4_PIXEL_FORMAT_BayerRG16 or @ref IC4_PIXEL_FORMAT_BayerGR16."]
    IC4_PIXEL_FORMAT_AnyBayer16 = -2129592575,
    #[doc = "< Invalid pixel format"]
    IC4_PIXEL_FORMAT_Invalid = -1,
}
#[doc = " @struct IC4_IMAGE_TYPE\n\n Represents an image type, including pixel format and image dimensions.\n\n Using a partially-specified image type is allowed when defining the buffer format of a sink.\n The sink will fill the other fields with data from the device automatically."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IC4_IMAGE_TYPE {
    #[doc = " Specifies the pixel format of the image.\n\n Setting \\a pixel_format to \\c IC4_PIXEL_FORMAT_Unspecified creates a partially-specified image type."]
    pub pixel_format: IC4_PIXEL_FORMAT,
    #[doc = " Specifies the width of the image.\n\n Setting \\a width to \\c 0 creates a partially-specified image type."]
    pub width: u32,
    #[doc = " Specifies the height of the image.\n\n Setting \\a height to \\c 0 creates a partially-specified image type."]
    pub height: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IC4_IMAGE_TYPE"][::std::mem::size_of::<IC4_IMAGE_TYPE>() - 12usize];
    ["Alignment of IC4_IMAGE_TYPE"][::std::mem::align_of::<IC4_IMAGE_TYPE>() - 4usize];
    ["Offset of field: IC4_IMAGE_TYPE::pixel_format"]
        [::std::mem::offset_of!(IC4_IMAGE_TYPE, pixel_format) - 0usize];
    ["Offset of field: IC4_IMAGE_TYPE::width"]
        [::std::mem::offset_of!(IC4_IMAGE_TYPE, width) - 4usize];
    ["Offset of field: IC4_IMAGE_TYPE::height"]
        [::std::mem::offset_of!(IC4_IMAGE_TYPE, height) - 8usize];
};
extern "C" {
    #[doc = " @brief Returns the name of a pixel format.\n\n @param[in] pixel_format\tA pixel format\n\n @return\tA pointer to a null-terminated string containing the name of the pixel format.\\n\n\t\t\tThe memory pointed to by the return value is valid forever does not need to be released.\\n\n\t\t\tIf the passed pixel format is unknown, the function returns \\c NULL."]
    pub fn ic4_pixelformat_tostring(
        pixel_format: IC4_PIXEL_FORMAT,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Returns the bits per pixel of a pixel format.\n\n @param[in] pixel_format  pixel format\n\n @return\tThe bits required to store one pixel using the given pixel format.\\n\n\t\t\tThe function returns \\c 0 if the bits per pixel of the pixel format is unknown."]
    pub fn ic4_pixelformat_bpp(pixel_format: IC4_PIXEL_FORMAT) -> usize;
}
extern "C" {
    #[doc = " @brief Convert a given image type into a string representation.\n\n @param[out] image_type\t\tPointer to a #IC4_IMAGE_TYPE value to receive the error code.\n @param[out] buffer\t\t\tPointer to a character array to receive the string.\\n\n\t\t\t\t\t\t\t\tThis parameter can be \\c NULL to find out the required space without allocating an initial array.\n @param[in, out] buffer_size\tPointer to a \\c size_t describing the length of the array pointed to by \\a buffer.\\n\n\t\t\t\t\t\t\t\tThe function always writes the actual number of characters required to store the string representation.\n\n @return\t\\c true on success.\n @return\tIf \\a image_type is \\c NULL, the function fails and returns \\c false.\n @return\tIf \\a buffer is not \\c NULL, and \\c *buffer_size is smaller than the required number\n\t\t\tof bytes to store the string, the function fails and returns \\c false.\n @return\tUse #ic4_get_last_error() to query error information."]
    pub fn ic4_imagetype_tostring(
        image_type: *const IC4_IMAGE_TYPE,
        buffer: *mut ::std::os::raw::c_char,
        buffer_size: *mut usize,
    ) -> bool;
}
#[doc = " @struct IC4_IMAGE_BUFFER\n @brief Represents an image buffer\n\n This type is opaque, programs only use pointers of type \\c IC4_IMAGE_BUFFER*.\n\n Image buffer objects are created automatically by the various @ref sink types,\n on request by a @ref IC4_BUFFER_POOL, or by calling @ref ic4_imagebuffer_wrap_memory().\n\n Image buffer objects are reference-counted.\n To share an image buffer object between multiple parts of a program, use ic4_imagebuffer_ref().\n Call ic4_imagebuffer_unref() when a reference is no longer required.\n\n If the reference count reaches zero, the image buffer is returned to its source to be reused. For example,\n an image buffer retrieved from ic4_queuesink_pop_output_buffer() will be re-queued."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IC4_IMAGE_BUFFER {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Increases the image buffer's internal reference count by one.\n\n @param[in] pImageBuffer An image buffer\n\n @return The pointer passed via \\a pImageBuffer\n\n @remarks If \\a pImageBuffer is \\c NULL, the function returns \\c NULL. An error value is not set.\n\n @see ic4_imagebuffer_unref"]
    pub fn ic4_imagebuffer_ref(pImageBuffer: *mut IC4_IMAGE_BUFFER) -> *mut IC4_IMAGE_BUFFER;
}
extern "C" {
    #[doc = " @brief Decreases the image buffer's internal reference count by one.\n\n If the reference count reaches zero, the image buffer is returned to its source to be reused.\n\n @param[in] pImageBuffer An image buffer\n\n @remarks If \\a pImageBuffer is \\c NULL, the function does nothing. An error value is not set.\n\n @see ic4_imagebuffer_ref"]
    pub fn ic4_imagebuffer_unref(pImageBuffer: *mut IC4_IMAGE_BUFFER);
}
extern "C" {
    #[doc = " @brief Returns a pointer to the data managed by the image buffer.\n\n @param[in] pImageBuffer An image buffer\n\n @return A pointer to the image data contained in the image buffer,\\n\n\t\t   or \\c NULL if an error occurred. Use ic4_get_last_error() to query error information.\n\n @remarks The memory pointed to by the returned pointer is valid as long as the image buffer object exists."]
    pub fn ic4_imagebuffer_get_ptr(
        pImageBuffer: *const IC4_IMAGE_BUFFER,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @brief Returns the pitch for the image buffer.\n\n The pitch is the distance between the starting memory location of two consecutive lines.\n\n @param[in] pImageBuffer\tAn image buffer\n\n @return\tThe pitch for this image buffer, or \\c 0 if an error occurred.\\n\n\t\t\tUse @ref ic4_get_last_error() to query error information."]
    pub fn ic4_imagebuffer_get_pitch(pImageBuffer: *const IC4_IMAGE_BUFFER) -> isize;
}
extern "C" {
    #[doc = " @brief Returns the size of the image buffer.\n\n @param[in] pImageBuffer\tAn image buffer\n\n @return\tThe size of this image buffer, or \\c 0 if an error occurred.\\n\n\t\t\tUse @ref ic4_get_last_error() to query error information."]
    pub fn ic4_imagebuffer_get_buffer_size(pImageBuffer: *const IC4_IMAGE_BUFFER) -> usize;
}
extern "C" {
    #[doc = " @brief Queries information about the image buffers's image data type.\n\n @param[in] pImageBuffer\t\tAn image buffer\n @param[out] image_type\tA #IC4_IMAGE_TYPE structure receiving the image data type information.\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information."]
    pub fn ic4_imagebuffer_get_image_type(
        pImageBuffer: *const IC4_IMAGE_BUFFER,
        image_type: *mut IC4_IMAGE_TYPE,
    ) -> bool;
}
#[doc = " A structure containing frame metadata"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IC4_FRAME_METADATA {
    #[doc = " @brief The frame number assigned to the image by the video capture device\n\n @remarks The behavior of this value, including starting value and possible rollover is device-specific."]
    pub device_frame_number: u64,
    #[doc = " @brief The time stamp assigned to the image by the video capture device\n\n @remarks The behavior of this value, including possible resets, its starting value or actual resolution is device-specific."]
    pub device_timestamp_ns: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IC4_FRAME_METADATA"][::std::mem::size_of::<IC4_FRAME_METADATA>() - 16usize];
    ["Alignment of IC4_FRAME_METADATA"][::std::mem::align_of::<IC4_FRAME_METADATA>() - 8usize];
    ["Offset of field: IC4_FRAME_METADATA::device_frame_number"]
        [::std::mem::offset_of!(IC4_FRAME_METADATA, device_frame_number) - 0usize];
    ["Offset of field: IC4_FRAME_METADATA::device_timestamp_ns"]
        [::std::mem::offset_of!(IC4_FRAME_METADATA, device_timestamp_ns) - 8usize];
};
extern "C" {
    #[doc = " @brief Retrieves metadata from an image buffer object.\n\n @param[in] pImageBuffer An image buffer\n @param[out] metadata A #IC4_FRAME_METADATA structure receiving the metadata.\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information."]
    pub fn ic4_imagebuffer_get_metadata(
        pImageBuffer: *const IC4_IMAGE_BUFFER,
        metadata: *mut IC4_FRAME_METADATA,
    ) -> bool;
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " @brief Contains options to configure the behavior of #ic4_imagebuffer_copy()."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IC4_IMAGEBUFFER_COPY_FLAGS {
    #[doc = " @brief Instructs #ic4_imagebuffer_copy() to skip the image data when copying.\n\n If included in the @c flags argument, #ic4_imagebuffer_copy() only copies the non-image parts of the buffer, and a\n program-defined algorithm can handle the image copy operation."]
    IC4_IMAGEBUFFER_COPY_SKIP_IMAGE = 1,
    #[doc = " @brief Instructs #ic4_imagebuffer_copy() to not copy the chunk data.\n\n This can be useful if the chunk data is large and not required in the destination frame."]
    IC4_IMAGEBUFFER_COPY_SKIP_CHUNKDATA = 2,
}
extern "C" {
    #[doc = " @brief Copies the contents of one image buffer to another image buffer.\n\n @param source\t\tSource buffer to copy from\n @param destination\tDestination buffer to copy into\n @param flags\t\t\tA bitwise combination of values from #IC4_IMAGEBUFFER_COPY_FLAGS.\n\n @remarks\n If the pixel format of the images in @c source and @c destination is not equal, the image is converted. For example,\n if the pixel format of @c source is #IC4_PIXEL_FORMAT_BayerRG8 and the pixel format of @c destination is #IC4_PIXEL_FORMAT_BGR8,\n a demosaicing operation creates a color image.\\n\n If @c flags contains #IC4_IMAGEBUFFER_COPY_SKIP_IMAGE, the function does not copy the image data. The function then only copies the meta data, and a\n program-defined algorithm can handle the image copy operation.\\n\n If @c flags contains #IC4_IMAGEBUFFER_COPY_SKIP_CHUNKDATA, the function does not copy the chunk data contained in @c source. This can be useful if the\n chunk data is large and not required.\n\n @note\n If the width or height of @c source and @c destination are not equal, the function fails and the error value is set to #IC4_ERROR_CONVERSION_NOT_SUPPORTED.\\n\n If there is no algorithm available for the requested conversion, the function fails and the error value is set to #IC4_ERROR_CONVERSION_NOT_SUPPORTED.\\n\n If the @c destination frame is not writable, the function fails and the error value is set to #IC4_ERROR_INVALID_OPERATION.\\n\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information."]
    pub fn ic4_imagebuffer_copy(
        source: *const IC4_IMAGE_BUFFER,
        destination: *mut IC4_IMAGE_BUFFER,
        flags: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Checks whether an image buffer object is (safely) writable.\n\n In some situations, image buffer objects are shared between the application holding a handle to the image buffer object\n and the library. For example, the image buffer might be shared with a display or a video writer.\n\n A shared buffer is not safely writable. Writing to a buffer that is shared can lead to unexpected behavior, for example a\n modification may partially appear in the result of an operation that is happening in parallel.\n\n Passing the image buffer into a function such as #ic4_display_display_buffer() or #ic4_videowriter_add_frame() can lead to a buffer becoming shared.\n\n @note\tThis function only checks for whether the buffer is shared with other parts of the library. It is the program's responsibility \\n\n\t\t\tto track whether multiple parts of the program are accessing the buffer's memory at the same time.\n\n @param[in] buffer\tAn image buffer object\n\n @note\tThis function does not track sharing between multiple parts of the application. If the application owns multiple references to\n\t\t\tan image buffer, or shares its buffer memory address between multiple threads, it is the application's responsibility to\n\t\t\tavoid data races.\n\n @return\t@c true if the image buffer is not shared with any part of the library, and is therefore safely writable.\\n\n\t\t\t@c false, if the image buffer is shared and therefore should not be written into."]
    pub fn ic4_imagebuffer_is_writable(buffer: *const IC4_IMAGE_BUFFER) -> bool;
}
#[doc = " @brief Defines a callback function to be called when an image buffer created by @ref ic4_imagebuffer_wrap_memory\n is destroyed and the image data will no longer be accessed through it.\n\n @param[in] ptr\t\t\tPointer to the image data as passed as @a data into @ref ic4_imagebuffer_wrap_memory\n @param[in] buffer_size\tBuffer size as passed as @a buffer_size into @ref ic4_imagebuffer_wrap_memory\n @param[in] user_ptr\t\tThe @a on_release_user_ptr parameter that was specified when the image buffer was created."]
pub type ic4_imagebuffer_memory_release = ::std::option::Option<
    unsafe extern "C" fn(
        ptr: *mut ::std::os::raw::c_void,
        buffer_size: usize,
        user_ptr: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " @brief Creates an image buffer object using external memory as storage area for the image data.\n\n This function can be useful when copying image data into buffers of third-party libraries:\n - Create an image object in the third-party library\n - Wrap the third-party library's image data into an @ref IC4_IMAGE_BUFFER using @ref ic4_imagebuffer_wrap_memory().\n - Copy the data from an existing image buffer object into the third-party image buffer using @ref ic4_imagebuffer_copy().\n\n @param[out] ppBuffer\t\t\t\tPointer to an image buffer handle to receive the new buffer object.\\n\n\t\t\t\t\t\t\t\t\tWhen the buffer is no longer required, release the object reference using @ref ic4_imagebuffer_unref().\n @param[in] data\t\t\t\t\tPointer to a region of memory to be used as image data by the image buffer object\n @param[in] buffer_size\t\t\tSize of the region of memory pointed to by @a data\n @param[in] pitch\t\t\t\t\tDifference between memory addresses of two consecutive lines of image data\n @param[in] image_type\t\t\tType of image to be stored in the image buffer\n @param[in] on_release\t\t\tOptional pointer to a callback function to be called when the image buffer object is destroyed.\\n\n\t\t\t\t\t\t\t\t\tThis can be useful when the program needs to keep track of the memory pointer to by the image buffer\n\t\t\t\t\t\t\t\t\tand has to release it once the image buffer object no longer exists.\\n\n\t\t\t\t\t\t\t\t\tThe lifetime of the image buffer can potentially be extended beyond the existance of its handle\n\t\t\t\t\t\t\t\t\twhen it is shared with API functions, e.g. @ref ic4_display_display_buffer or @ref ic4_videowriter_add_frame.\n @param[in] on_release_user_ptr\tUser pointer to be passed when calling @a on_release.\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information."]
    pub fn ic4_imagebuffer_wrap_memory(
        ppBuffer: *mut *mut IC4_IMAGE_BUFFER,
        data: *mut ::std::os::raw::c_void,
        buffer_size: usize,
        pitch: isize,
        image_type: *const IC4_IMAGE_TYPE,
        on_release: ic4_imagebuffer_memory_release,
        on_release_user_ptr: *mut ::std::os::raw::c_void,
    ) -> bool;
}
#[doc = " Contains function pointers used to configure a custom allocator for image buffers"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IC4_ALLOCATOR_CALLBACKS {
    #[doc = " @brief Notifies the user that the allocator will not receive any additional callback function calls.\n\n @anchor allocator_release\n\n Any resources attached to the \\c context parameter can be released.\n\n @param[in] context   The \\c allocator_context parameter that was passed to the sink creation function.\n\n @note\n The \\c release callback function is executed on the thread that destroys the sink using the final call to #ic4_sink_unref()."]
    pub release: ::std::option::Option<unsafe extern "C" fn(context: *mut ::std::os::raw::c_void)>,
    #[doc = " @brief Requests the allocator to allocate a memory buffer.\n\n @param[in] context       The \\c allocator_context parameter that was passed to the sink creation function\n @param[in] buffer_size   The size of the requested memory buffer\n @param[in] alignment     Requests memory to be allocated on a specific alignment boundary.\\n\n                          This value is always a power of 2.\n @param[out] buffer_ptr   A pointer to a pointer that receives the address of the newly-allocated buffer\n @param[out] user_data    User data to attach to the buffer. The user data is passed to @ref free_buffer when\n                          the allocated memory is freed again.\n\n @return \\c true on success. If the allocation could not be performed, return \\c false."]
    pub allocate_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            buffer_size: usize,
            alignment: usize,
            buffer_ptr: *mut *mut ::std::os::raw::c_void,
            user_data: *mut *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = " @brief Requests the allocator to free a previously-allocated memory buffer.\n\n @param[in] context       The \\c allocator_context parameter that was passed to the sink creation function\n @param[in] buffer_ptr    Pointer to the memory buffer to be freed\n @param[in] user_data     The user data that was returned from @ref allocate_buffer when the memory buffer was allocated"]
    pub free_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ::std::os::raw::c_void,
            buffer_ptr: *mut ::std::os::raw::c_void,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IC4_ALLOCATOR_CALLBACKS"][::std::mem::size_of::<IC4_ALLOCATOR_CALLBACKS>() - 24usize];
    ["Alignment of IC4_ALLOCATOR_CALLBACKS"]
        [::std::mem::align_of::<IC4_ALLOCATOR_CALLBACKS>() - 8usize];
    ["Offset of field: IC4_ALLOCATOR_CALLBACKS::release"]
        [::std::mem::offset_of!(IC4_ALLOCATOR_CALLBACKS, release) - 0usize];
    ["Offset of field: IC4_ALLOCATOR_CALLBACKS::allocate_buffer"]
        [::std::mem::offset_of!(IC4_ALLOCATOR_CALLBACKS, allocate_buffer) - 8usize];
    ["Offset of field: IC4_ALLOCATOR_CALLBACKS::free_buffer"]
        [::std::mem::offset_of!(IC4_ALLOCATOR_CALLBACKS, free_buffer) - 16usize];
};
#[doc = " @struct IC4_BUFFER_POOL\n @brief The buffer pool allows allocating additional image buffers for use by the program.\n\n This type is opaque, programs only use pointers of type \\c IC4_BUFFER_POOL*.\n\n Most programs will only use image buffers provided by one of the sink types.\n However, some programs require additional buffers, for example to use as destination for image processing.\n\n To create additional buffers, first create a buffer pool using #ic4_bufferpool_create().\n Then, use #ic4_bufferpool_get_buffer() to create a new image buffer with a specified image type.\n Allocation options can be specified to customizer image buffer's memory alignment, pitch and total buffer size.\n\n When the image buffer is no longer required, call #ic4_imagebuffer_unref on it. The buffer will then be returned to the buffer pool.\n\n The buffer pool has configurable caching behavior. By default, the buffer pool will cache one image buffer and return it the next\n time a matching image buffer is requested.\n\n Buffer pool objects are reference-counted, and created with an initial reference count of one.\n To share a buffer pool object between multiple parts of a program, create a new reference by calling #ic4_bufferpool_ref().\n When a reference is no longer required, call #ic4_bufferpool_unref().\n\n If the buffer pool object's internal reference count reaches zero, the buffer pool object is destroyed.\n Even after that, image buffers created by the buffer pool are still valid until they are released by calling #ic4_imagebuffer_unref."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IC4_BUFFER_POOL {
    _unused: [u8; 0],
}
#[doc = " @brief Configures the behavior of a #IC4_BUFFER_POOL."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IC4_BUFFER_POOL_CONFIG {
    #[doc = " @brief Maximum number of frames to keep in the buffer pool's cache"]
    pub cache_frames_max: usize,
    #[doc = " @brief Maximum size of the buffer pool cache in bytes, or @c 0 to not limit by size"]
    pub cache_bytes_max: usize,
    #[doc = " @brief A structure containing function pointers to customize the buffer pool's allocator.\n\n This parameter is optional, set all callback functions to \\c NULL to use the default allocator.\n\n If @ref IC4_ALLOCATOR_CALLBACKS::allocate_buffer is set, @ref IC4_ALLOCATOR_CALLBACKS::free_buffer must be set as well."]
    pub allocator: IC4_ALLOCATOR_CALLBACKS,
    #[doc = " @brief A user-defined value that is passed to the allocator callbacks\n\n If \\c callback_context points to a memory location, and callback functions access that memory,\n the program has to make sure that the memory is valid until the @ref IC4_ALLOCATOR_CALLBACKS::release callback is executed."]
    pub allocator_context: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IC4_BUFFER_POOL_CONFIG"][::std::mem::size_of::<IC4_BUFFER_POOL_CONFIG>() - 48usize];
    ["Alignment of IC4_BUFFER_POOL_CONFIG"]
        [::std::mem::align_of::<IC4_BUFFER_POOL_CONFIG>() - 8usize];
    ["Offset of field: IC4_BUFFER_POOL_CONFIG::cache_frames_max"]
        [::std::mem::offset_of!(IC4_BUFFER_POOL_CONFIG, cache_frames_max) - 0usize];
    ["Offset of field: IC4_BUFFER_POOL_CONFIG::cache_bytes_max"]
        [::std::mem::offset_of!(IC4_BUFFER_POOL_CONFIG, cache_bytes_max) - 8usize];
    ["Offset of field: IC4_BUFFER_POOL_CONFIG::allocator"]
        [::std::mem::offset_of!(IC4_BUFFER_POOL_CONFIG, allocator) - 16usize];
    ["Offset of field: IC4_BUFFER_POOL_CONFIG::allocator_context"]
        [::std::mem::offset_of!(IC4_BUFFER_POOL_CONFIG, allocator_context) - 40usize];
};
extern "C" {
    #[doc = " @brief Creates a new buffer pool.\n\n @param[in] ppPool\tPointer to a buffer pool handle to receive the new buffer pool.\n\t\t\t\t\t\tWhen the buffer pool is no longer required, release the object reference using #ic4_bufferpool_unref().\n @param[in] config\tPointer to a structure containing the buffer pool configuration\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information."]
    pub fn ic4_bufferpool_create(
        ppPool: *mut *mut IC4_BUFFER_POOL,
        config: *const IC4_BUFFER_POOL_CONFIG,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Increases the buffer pool's internal reference count by one.\n\n @param[in] pPool A pointer to a buffer pool\n\n @return The pointer passed via \\a pPool\n\n @remarks If \\a pPool is \\c NULL, the function returns \\c NULL. An error value is not set.\n\n @see ic4_bufferpool_unref"]
    pub fn ic4_bufferpool_ref(pPool: *mut IC4_BUFFER_POOL) -> *mut IC4_BUFFER_POOL;
}
extern "C" {
    #[doc = " @brief Decreases the pool's internal reference count by one.\n\n If the reference count reaches zero, the object is destroyed.\n\n @param[in] pPool A pointer to a buffer pool\n\n @remarks\n If \\a pPool is \\c NULL, the function does nothing. An error value is not set.\n\n @see ic4_bufferpool_ref"]
    pub fn ic4_bufferpool_unref(pPool: *mut IC4_BUFFER_POOL);
}
#[doc = " @brief Contains options to configure the allocation when requesting an image buffer from a buffer pool.\n\n @see ic4_bufferpool_get_buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IC4_BUFFERPOOL_ALLOCATION_OPTIONS {
    #[doc = " @brief Specifies the alignment of the address of the buffer's memory.\n\n Setting this to 0 lets the buffer pool select an alignment automatically.\n\n The alignment must be a power of 2."]
    pub alignment: usize,
    #[doc = " @brief Specifies the pitch to use when allocating the buffer.\n\n A value of 0 lets the buffer pool select a pitch automatically.\n\n Setting a pitch that is smaller than the amount of memory required to store one line of image data will lead to an error."]
    pub pitch: isize,
    #[doc = " @brief Overrides the automatic buffer size calculation.\n\n A value of 0 lets the buffer pool calculate the required buffer size automatically.\n\n Setting a size that is smaller than the amount of memory required to store an image of a known format will lead to an error."]
    pub buffer_size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IC4_BUFFERPOOL_ALLOCATION_OPTIONS"]
        [::std::mem::size_of::<IC4_BUFFERPOOL_ALLOCATION_OPTIONS>() - 24usize];
    ["Alignment of IC4_BUFFERPOOL_ALLOCATION_OPTIONS"]
        [::std::mem::align_of::<IC4_BUFFERPOOL_ALLOCATION_OPTIONS>() - 8usize];
    ["Offset of field: IC4_BUFFERPOOL_ALLOCATION_OPTIONS::alignment"]
        [::std::mem::offset_of!(IC4_BUFFERPOOL_ALLOCATION_OPTIONS, alignment) - 0usize];
    ["Offset of field: IC4_BUFFERPOOL_ALLOCATION_OPTIONS::pitch"]
        [::std::mem::offset_of!(IC4_BUFFERPOOL_ALLOCATION_OPTIONS, pitch) - 8usize];
    ["Offset of field: IC4_BUFFERPOOL_ALLOCATION_OPTIONS::buffer_size"]
        [::std::mem::offset_of!(IC4_BUFFERPOOL_ALLOCATION_OPTIONS, buffer_size) - 16usize];
};
extern "C" {
    #[doc = " @brief Gets a buffer from the buffer pool.\n\n The buffer is either newly allocated, or retrieved from the buffer pool's buffer cache.\n\n @param[in] pPool\t\t\t\tA buffer pool\n @param[in] image_type\t\tImage type of the requested buffer\n @param[in] options\t\t\tA pointer to a #IC4_BUFFERPOOL_ALLOCATION_OPTIONS structure specifying advance allocation options.\\n\n\t\t\t\t\t\t\t\tMay be @c NULL to use default allocation parameters.\n @param[out] ppImageBuffer\tPointer to an image buffer handle to receive the buffer.\\n\n\t\t\t\t\t\t\t\tWhen the buffer is no longer required, release the object reference using #ic4_imagebuffer_unref().\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information."]
    pub fn ic4_bufferpool_get_buffer(
        pPool: *mut IC4_BUFFER_POOL,
        image_type: *const IC4_IMAGE_TYPE,
        options: *const IC4_BUFFERPOOL_ALLOCATION_OPTIONS,
        ppImageBuffer: *mut *mut IC4_IMAGE_BUFFER,
    ) -> bool;
}
#[doc = " @struct IC4_PROPERTY_MAP\n\n @brief Represents the property interface of a component, usually a video capture device.\n\n A property map offers quick access to known properties as well as functions to enumerate all features through the category tree.\n\n This type is opaque, programs only use pointers of type \\c IC4_PROPERTY_MAP*.\n\n Property maps are created by their respective component when asked for, for example by calling #ic4_grabber_device_get_property_map()\n or #ic4_videowriter_get_property_map().\n\n Property map objects are reference-counted.\n To share a propertyp map between multiple parts of a program, create a new reference by calling #ic4_propmap_ref().\n When a reference is no longer required, call #ic4_propmap_unref(). The property map is destroyed when the final reference\n is released.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IC4_PROPERTY_MAP {
    _unused: [u8; 0],
}
#[doc = " @struct IC4_PROPERTY\n\n @brief Represents a property of a component, usually of a video capture device.\n\n All property types are referred to by pointers to \\c IC4_PROPERTY, there are no specialized types for\n different property types.\n\n \\c IC4_PROPERTY also represents enumeration entries, even though they are not actually property that is part of\n the category tree. Nevertheless, enumeration entries support all standard property operations.\n\n Property objects are created in multiple ways:\n\t- By calling @ref ic4_propmap_find() or one of its typed sibling functions like @ref ic4_propmap_find_integer().\n\t- By calling @ref ic4_proplist_at() to retrieve a property out of a property list, that was previously obtained:\n\t\t- By calling @ref ic4_prop_category_get_features() to get all properties from a category.\n\t\t- By calling @ref ic4_prop_enum_get_entries() to get the enumeration entries of an enumeration property.\n\t\t- By calling @ref ic4_prop_get_selected_props() to get the properties selected by a property.\n\t\t- By calling @ref ic4_propmap_get_all() to get all properties in a property map's category tree.\n\n Property objects obtained in any of these ways that refer to the same device property will always have the same pointer value.\n\n Calling a function expecting a property with a certain property type on a property with a different type will fail\n and the error value will be set to @ref IC4_ERROR_GENICAM_TYPE_MISMATCH."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IC4_PROPERTY {
    _unused: [u8; 0],
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " @brief Defines the possible property types\n\n The property type defines the possible operations on a property and its data type."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IC4_PROPERTY_TYPE {
    #[doc = "< Not a valid property type, indicates an error"]
    IC4_PROPTYPE_INVALID = 0,
    #[doc = "< Integer property"]
    IC4_PROPTYPE_INTEGER = 1,
    #[doc = "< Float property"]
    IC4_PROPTYPE_FLOAT = 2,
    #[doc = "< Enumeration property"]
    IC4_PROPTYPE_ENUMERATION = 3,
    #[doc = "< Boolean property"]
    IC4_PROPTYPE_BOOLEAN = 4,
    #[doc = "< String property"]
    IC4_PROPTYPE_STRING = 5,
    #[doc = "< Command property"]
    IC4_PROPTYPE_COMMAND = 6,
    #[doc = "< Category property"]
    IC4_PROPTYPE_CATEGORY = 7,
    #[doc = "< Register property"]
    IC4_PROPTYPE_REGISTER = 8,
    #[doc = "< Port property"]
    IC4_PROPTYPE_PORT = 9,
    #[doc = "< Enumeration entry property"]
    IC4_PROPTYPE_ENUMENTRY = 10,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " @brief Defines the possible property visibilities\n\n Each property has a visibility hint that can be used to create user interfaces for different user types."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IC4_PROPERTY_VISIBILITY {
    #[doc = "< Beginner visibility"]
    IC4_PROPVIS_BEGINNER = 0,
    #[doc = "< Expert visibility"]
    IC4_PROPVIS_EXPERT = 1,
    #[doc = "< Guru visibility"]
    IC4_PROPVIS_GURU = 2,
    #[doc = "< Invisible"]
    IC4_PROPVIS_INVISIBLE = 3,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " @brief Defines the possible property increment modes for Integer and Float properties"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IC4_PROPERTY_INCREMENT_MODE {
    #[doc = " @brief The property used a fixed step between valid values.\n\n Use #ic4_prop_integer_get_inc() or #ic4_prop_float_get_inc() to get the property's step size."]
    IC4_PROPINCMODE_INCREMENT = 0,
    #[doc = " @brief The property defines a set of valid values.\n\n Use @ref ic4_prop_integer_get_valid_value_set() or @ref ic4_prop_float_get_valid_value_set() to query the set of valid values."]
    IC4_PROPINCMODE_VALUESET = 1,
    #[doc = " @brief The property allows setting all values between its minimum and maximum value.\n\n This mode is only valid for Float properties.\n\n Integer properties report increment 1 if they want to allow every possible value between their minimum and maximum value."]
    IC4_PROPINCMODE_NONE = 2,
}
#[doc = " @struct IC4_PROPERTY_LIST\n\n @brief Represents a list of properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IC4_PROPERTY_LIST {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Increases the property map's internal reference count by one.\n\n @param[in] map A property map\n\n @return The pointer passed via \\a map\n\n @remarks If \\a map is \\c NULL, the function returns \\c NULL. An error value is not set.\n\n @see ic4_propmap_unref"]
    pub fn ic4_propmap_ref(map: *mut IC4_PROPERTY_MAP) -> *mut IC4_PROPERTY_MAP;
}
extern "C" {
    #[doc = " @brief Decreases the property map's internal reference count by one.\n\n If the reference count reaches zero, the object is destroyed.\n\n @param[in] map A property map\n\n @remarks\n If \\a map is \\c NULL, the function does nothing. An error value is not set.\n\n @remarks\n #IC4_PROPERTY objects retrieved from this property map will stay valid after the property map has been destroyed.\n\n @see ic4_propmap_ref"]
    pub fn ic4_propmap_unref(map: *mut IC4_PROPERTY_MAP);
}
extern "C" {
    #[doc = " @brief Execute a command with a known name.\n\n @param[in] map\t\tA property map\n @param[in] prop_name\tName of a command property inside \\c map\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If there is no with the name \\c prop_name in \\c map, the function fails and the error value is set to #IC4_ERROR_GENICAM_FEATURE_NOT_FOUND. \\n\n If there is a property with the name \\c prop_name, but it is not a command property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n"]
    pub fn ic4_propmap_execute_command(
        map: *mut IC4_PROPERTY_MAP,
        prop_name: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Get the value of a property with a known name as an integer value.\n\n The behavior depends on the type of the property:\n - For integer properties, the value is returned directly.\n - For boolean properties, the value returned is @c 1 or @c 0.\n - For all other property types, the call results in an error (@ref IC4_ERROR_GENICAM_TYPE_MISMATCH).\n\n @param[in] map\t\t\tA property map\n @param[in] prop_name\t\tName of a property inside @c map\n @param[out] pValue\t\tPointer to an integer to receive the value of the property\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If there is no property with the name \\c prop_name in \\c map, the function fails and the error value is set to #IC4_ERROR_GENICAM_FEATURE_NOT_FOUND. \\n"]
    pub fn ic4_propmap_get_value_int64(
        map: *mut IC4_PROPERTY_MAP,
        prop_name: *const ::std::os::raw::c_char,
        pValue: *mut i64,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Get the value of a property with a known name as a double value.\n\n The behavior depends on the type of the property:\n - For integer properties, the value is converted to @c double.\n - For float properties, the value is returned directly.\n - For all other property types, the call results in an error (@ref IC4_ERROR_GENICAM_TYPE_MISMATCH).\n\n @param[in] map\t\t\tA property map\n @param[in] prop_name\t\tName of a property inside @c map\n @param[out] pValue\t\tPointer to a double to receive the value of the property\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If there is no property with the name \\c prop_name in \\c map, the function fails and the error value is set to #IC4_ERROR_GENICAM_FEATURE_NOT_FOUND. \\n"]
    pub fn ic4_propmap_get_value_double(
        map: *mut IC4_PROPERTY_MAP,
        prop_name: *const ::std::os::raw::c_char,
        pValue: *mut f64,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Get the value of a property with a known name as a bool value.\n\n The behavior depends on the type of the property:\n - For boolean properties, the value is returned directly.\n - For enumeration properties, a value is returned if the name of the currently selected entry unambiguously suggests to represent @c true or @c false.\n - For all other property types, the call results in an error (@ref IC4_ERROR_GENICAM_TYPE_MISMATCH).\n\n @param[in] map\t\t\tA property map\n @param[in] prop_name\t\tName of a property inside @c map\n @param[out] pValue\t\tPointer to a double to receive the value of the property\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If there is no property with the name \\c prop_name in \\c map, the function fails and the error value is set to #IC4_ERROR_GENICAM_FEATURE_NOT_FOUND. \\n"]
    pub fn ic4_propmap_get_value_bool(
        map: *mut IC4_PROPERTY_MAP,
        prop_name: *const ::std::os::raw::c_char,
        pValue: *mut bool,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Get the value of a property with a known name as a string value.\n\n The behavior depends on the type of the property:\n - For integer properties, the value is converted to a string\n - For float properties, the value is converted to a string\n - For boolean properties, the value is converted to the string @c \"true\" or @c \"false\".\n - For enumeration properties, the name of the currently selected entry is returned.\n - For string properties, the value is returned directly.\n - For all other property types, the call results in an error (@ref IC4_ERROR_GENICAM_TYPE_MISMATCH).\n\n @param[in] map\t\t\t\tA property map\n @param[in] prop_name\t\t\tName of a property inside \\c map\n @param[out] buffer\t\t\tPointer to a character array to receive the string value.\\n\n\t\t\t\t\t\t\t\tThis parameter can be \\c NULL to find out the required space without allocating an initial array.\n @param[in, out] buffer_size\tPointer to a \\c size_t describing the length of the array pointed to by \\a buffer.\\n\n\t\t\t\t\t\t\t\tThe function always writes the actual number of characters required to store the string representation.\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If there is no property with the name \\c prop_name in \\c map, the function fails and the error value is set to #IC4_ERROR_GENICAM_FEATURE_NOT_FOUND. \\n"]
    pub fn ic4_propmap_get_value_string(
        map: *mut IC4_PROPERTY_MAP,
        prop_name: *const ::std::os::raw::c_char,
        buffer: *mut ::std::os::raw::c_char,
        buffer_size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Set the value of a property with a known name to the passed integer value.\n\n The behavior depends on the type of the property:\n - For integer properties, the value is set directly.\n - For float properties, the value is set directly.\n - For boolean properties, if the value is @c 1 or @c 0, it is set to @c true or @c false respectively. Other values result in an error.\n - For enumeration properties, the numeric value is set if the property is @c PixelFormat. Other properties result in an error.\n - For command properties, the command is executed if @a value is @c 1.\n - For all other property types, the call results in an error (@ref IC4_ERROR_GENICAM_TYPE_MISMATCH).\n\n @param[in] map\t\tA property map\n @param[in] prop_name\tName of a property inside \\c map\n @param[in] value\t\tNew value to be set for the property identified by \\c prop_name\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If there is no property with the name \\c prop_name in \\c map, the function fails and the error value is set to #IC4_ERROR_GENICAM_FEATURE_NOT_FOUND. \\n"]
    pub fn ic4_propmap_set_value_int64(
        map: *mut IC4_PROPERTY_MAP,
        prop_name: *const ::std::os::raw::c_char,
        value: i64,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Set the value of a property with a known name to the passed double value.\n\n The behavior depends on the type of the property:\n - For integer properties, the value is rounded to the nearest integer.\n - For float properties, the value is set directly.\n - For all other property types, the call results in an error (@ref IC4_ERROR_GENICAM_TYPE_MISMATCH).\n\n @param[in] map\t\tA property map\n @param[in] prop_name\tName of a property inside \\c map\n @param[in] value\t\tNew value to be set for the property identified by \\c prop_name\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If there is no property with the name \\c prop_name in \\c map, the function fails and the error value is set to #IC4_ERROR_GENICAM_FEATURE_NOT_FOUND. \\n"]
    pub fn ic4_propmap_set_value_double(
        map: *mut IC4_PROPERTY_MAP,
        prop_name: *const ::std::os::raw::c_char,
        value: f64,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Set the value of a property with a known name to the passed bool value.\n\n The behavior depends on the type of the property:\n - For boolean properties, the value is set directly.\n - For enumeration properties, it selects the entry with a name that unambiguously suggests to represent @c true or @c false, if available.\n - For command properties, the command is executed if @a value is @c true.\n - For all other property types, the call results in an error (@ref IC4_ERROR_GENICAM_TYPE_MISMATCH).\n\n @param[in] map\t\tA property map\n @param[in] prop_name\tName of a property inside \\c map\n @param[in] value\t\tNew value to be set for the property identified by \\c prop_name\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If there is no property with the name \\c prop_name in \\c map, the function fails and the error value is set to #IC4_ERROR_GENICAM_FEATURE_NOT_FOUND. \\n"]
    pub fn ic4_propmap_set_value_bool(
        map: *mut IC4_PROPERTY_MAP,
        prop_name: *const ::std::os::raw::c_char,
        value: bool,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Set the value of a property with a known name to the passed string value.\n\n The behavior depends on the type of the property:\n - For integer properties, the string is parsed, and the found integer value is set\n - For float properties, the string is parsed, and the found floating-point value is set\n - For boolean properties, a value is set if the string can be unambiguously identified to represent @c true or @c false.\n - For enumeration properties, the entry with a name or display name matching the value is set.\n - For string properties, the value is set directly.\n - For command properties, the command is executed if @a value is @c \"1\", @c \"true\" or @c \"execute\".\n - For all other property types, the call results in an error (@ref IC4_ERROR_GENICAM_TYPE_MISMATCH).\n\n @param[in] map\t\tA property map\n @param[in] prop_name\tName of a property inside \\c map\n @param[in] value\t\tNew value to be set for the property identified by \\c prop_name\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If there is no property with the name \\c prop_name in \\c map, the function fails and the error value is set to #IC4_ERROR_GENICAM_FEATURE_NOT_FOUND. \\n"]
    pub fn ic4_propmap_set_value_string(
        map: *mut IC4_PROPERTY_MAP,
        prop_name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns a property object representing the property with the passed name.\n\n @param[in]\tmap\t\t\tA property map\n @param[in]\tprop_name\tThe name of a property inside \\c map\n @param[out]\tppProperty\tPointer to a handle receiving the property object\n\t\t\t\t\t\t\tWhen the property is no longer required, release the object reference using #ic4_prop_unref().\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If there is no property with the name \\c prop_name inside \\c map, the function fails and the error value is set to #IC4_ERROR_GENICAM_FEATURE_NOT_FOUND. \\n"]
    pub fn ic4_propmap_find(
        map: *mut IC4_PROPERTY_MAP,
        prop_name: *const ::std::os::raw::c_char,
        ppProperty: *mut *mut IC4_PROPERTY,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns a property object representing the command property with the passed name.\n\n @param[in]\tmap\t\t\tA property map\n @param[in]\tprop_name\tThe name of a command property inside \\c map\n @param[out]\tppProperty\tPointer to a handle receiving the property object\n\t\t\t\t\t\t\tWhen the property is no longer required, release the object reference using #ic4_prop_unref().\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If there is no property with the name \\c prop_name inside \\c map, the function fails and the error value is set to #IC4_ERROR_GENICAM_FEATURE_NOT_FOUND. \\n\n If there is a property with the name \\c prop_name, but it is not a command property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n"]
    pub fn ic4_propmap_find_command(
        map: *mut IC4_PROPERTY_MAP,
        prop_name: *const ::std::os::raw::c_char,
        ppProperty: *mut *mut IC4_PROPERTY,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns a property object representing the integer property with the passed name.\n\n @param[in]\tmap\t\t\tA property map\n @param[in]\tprop_name\tThe name of an integer property inside \\c map\n @param[out]\tppProperty\tPointer to a handle receiving the property object\n\t\t\t\t\t\t\tWhen the property is no longer required, release the object reference using #ic4_prop_unref().\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If there is no property with the name \\c prop_name inside \\c map, the function fails and the error value is set to #IC4_ERROR_GENICAM_FEATURE_NOT_FOUND. \\n\n If there is a property with the name \\c prop_name, but it is not an integer property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n"]
    pub fn ic4_propmap_find_integer(
        map: *mut IC4_PROPERTY_MAP,
        prop_name: *const ::std::os::raw::c_char,
        ppProperty: *mut *mut IC4_PROPERTY,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns a property object representing the float property with the passed name.\n\n @param[in]\tmap\t\t\tA property map\n @param[in]\tprop_name\tThe name of a float property inside \\c map\n @param[out]\tppProperty\tPointer to a handle receiving the property object\n\t\t\t\t\t\t\tWhen the property is no longer required, release the object reference using #ic4_prop_unref().\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If there is no property with the name \\c prop_name inside \\c map, the function fails and the error value is set to #IC4_ERROR_GENICAM_FEATURE_NOT_FOUND. \\n\n If there is a property with the name \\c prop_name, but it is not a float property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n"]
    pub fn ic4_propmap_find_float(
        map: *mut IC4_PROPERTY_MAP,
        prop_name: *const ::std::os::raw::c_char,
        ppProperty: *mut *mut IC4_PROPERTY,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns a property object representing the boolean property with the passed name.\n\n @param[in]\tmap\t\t\tA property map\n @param[in]\tprop_name\tThe name of a boolean property inside \\c map\n @param[out]\tppProperty\tPointer to a handle receiving the property object\n\t\t\t\t\t\t\tWhen the property is no longer required, release the object reference using #ic4_prop_unref().\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If there is no property with the name \\c prop_name inside \\c map, the function fails and the error value is set to #IC4_ERROR_GENICAM_FEATURE_NOT_FOUND. \\n\n If there is a property with the name \\c prop_name, but it is not a boolean property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n"]
    pub fn ic4_propmap_find_boolean(
        map: *mut IC4_PROPERTY_MAP,
        prop_name: *const ::std::os::raw::c_char,
        ppProperty: *mut *mut IC4_PROPERTY,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns a property object representing the string property with the passed name.\n\n @param[in]\tmap\t\t\tA property map\n @param[in]\tprop_name\tThe name of a string property inside \\c map\n @param[out]\tppProperty\tPointer to a handle receiving the property object\n\t\t\t\t\t\t\tWhen the property is no longer required, release the object reference using #ic4_prop_unref().\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If there is no property with the name \\c prop_name inside \\c map, the function fails and the error value is set to #IC4_ERROR_GENICAM_FEATURE_NOT_FOUND. \\n\n If there is a property with the name \\c prop_name, but it is not a string property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n"]
    pub fn ic4_propmap_find_string(
        map: *mut IC4_PROPERTY_MAP,
        prop_name: *const ::std::os::raw::c_char,
        ppProperty: *mut *mut IC4_PROPERTY,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns a property object representing the enumeration property with the passed name.\n\n @param[in]\tmap\t\t\tA property map\n @param[in]\tprop_name\tThe name of an enumeration property inside \\c map\n @param[out]\tppProperty\tPointer to a handle receiving the property object\n\t\t\t\t\t\t\tWhen the property is no longer required, release the object reference using #ic4_prop_unref().\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If there is no property with the name \\c prop_name inside \\c map, the function fails and the error value is set to #IC4_ERROR_GENICAM_FEATURE_NOT_FOUND. \\n\n If there is a property with the name \\c prop_name, but it is not an enumeration property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n"]
    pub fn ic4_propmap_find_enumeration(
        map: *mut IC4_PROPERTY_MAP,
        prop_name: *const ::std::os::raw::c_char,
        ppProperty: *mut *mut IC4_PROPERTY,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns a property object representing the register property with the passed name.\n\n @param[in]\tmap\t\t\tA property map\n @param[in]\tprop_name\tThe name of a register property inside \\c map\n @param[out]\tppProperty\tPointer to a handle receiving the property object\n\t\t\t\t\t\t\tWhen the property is no longer required, release the object reference using #ic4_prop_unref().\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If there is no property with the name \\c prop_name inside \\c map, the function fails and the error value is set to #IC4_ERROR_GENICAM_FEATURE_NOT_FOUND. \\n\n If there is a property with the name \\c prop_name, but it is not a register property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n"]
    pub fn ic4_propmap_find_register(
        map: *mut IC4_PROPERTY_MAP,
        prop_name: *const ::std::os::raw::c_char,
        ppProperty: *mut *mut IC4_PROPERTY,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns a property object representing the category property with the passed name.\n\n @param[in]\tmap\t\t\tA property map\n @param[in]\tprop_name\tThe name of a category property inside \\c map\n @param[out]\tppProperty\tPointer to a handle receiving the property object\n\t\t\t\t\t\t\tWhen the property is no longer required, release the object reference using #ic4_prop_unref().\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If there is no property with the name \\c prop_name inside \\c map, the function fails and the error value is set to #IC4_ERROR_GENICAM_FEATURE_NOT_FOUND. \\n\n If there is a property with the name \\c prop_name, but it is not a category property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n"]
    pub fn ic4_propmap_find_category(
        map: *mut IC4_PROPERTY_MAP,
        prop_name: *const ::std::os::raw::c_char,
        ppProperty: *mut *mut IC4_PROPERTY,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns a list of all properties reachable from the property map's \"Root\" category.\n\n @param[in]\tmap\t\t\tA property map\n @param[out]\tppList\t\tA pointer to a property list receiving the list of properties.\\n\n\t\t\t\t\t\t\tWhen the property list is no longer required, release the object reference using #ic4_proplist_unref().\n\n @note\n This generated list does not include category properties.\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information."]
    pub fn ic4_propmap_get_all(
        map: *mut IC4_PROPERTY_MAP,
        ppList: *mut *mut IC4_PROPERTY_LIST,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Enables the use of the chunk data in the passed #IC4_IMAGE_BUFFER as a backend for chunk properties in the property map.\n\n @param[in]\tmap\t\t\t\tA property map\n @param[in]\timage_buffer\tAn image buffer with chunk data.\\n\n\t\t\t\t\t\t\t\tThis parameter may be \\c NULL to disconnect the previously connected buffer.\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n The property map takes a reference to the passed image buffer, extending its lifetime and preventing automatic reuse.\n The reference is released when a new image buffer is connected to the property map, or \\c NULL is passed in the \\c image_buffer argument.\n"]
    pub fn ic4_propmap_connect_chunkdata(
        map: *mut IC4_PROPERTY_MAP,
        image_buffer: *mut IC4_IMAGE_BUFFER,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Saves the state of the properties in this property map into a file.\n\n @param[in]\tmap\t\tA property map\n @param[in]\tpath\tA path to a file that the property state is written to\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @note\n The actual set of properties that is stored by this function is controlled by the object the property map belongs to.\\n\n To restore the properties at a later time, use #ic4_propmap_deserialize_from_file.\n\n @see ic4_propmap_deserialize_from_file\n @see ic4_propmap_serialize_to_memory"]
    pub fn ic4_propmap_serialize_to_file(
        map: *mut IC4_PROPERTY_MAP,
        path: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn ic4_propmap_serialize_to_fileW(map: *mut IC4_PROPERTY_MAP, path: *const u16) -> bool;
}
#[doc = " @brief Callback function called to allocate memory during the call of #ic4_propmap_serialize_to_memory.\n\n @param[in]\tsize\tSize of the memory buffer to be allocated.\n\n @return\t\tThe pointer to the allocated memory buffer, or @c NULL if the allocation was not possible.\n\n @note\n If this function returns @c NULL, the call to #ic4_propmap_serialize_to_memory will fail.\n\n @see ic4_propmap_serialize_to_memory"]
pub type ic4_serialization_allocator =
    ::std::option::Option<unsafe extern "C" fn(size: usize) -> *mut ::std::os::raw::c_void>;
extern "C" {
    #[doc = " @brief Saves the state of the properties in this property map in a memory buffer.\n\n @param[in]\t\tmap\t\t\tA property map\n @param[in]\t\talloc\t\tPointer to a function that allocates the memory buffer.\\n\n\t\t\t\t\t\t\t\tFor example, @c malloc can be passed here.\n @param[out]\t\tppData\t\tPointer to a pointer to receive the newly-allocated memory buffer containing the properties.\\n\n\t\t\t\t\t\t\t\tThe caller is responsible for releasing the memory, using a function that can free memory returned by @c alloc.\n @param[out]\t\tdata_size\tPointer to size_t to receive the size of the memory buffer allocated by the call\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @note\n The actual set of properties that is stored by this function is controlled by the object the property map belongs to.\\n\n To restore the properties at a later time, use #ic4_propmap_deserialize_from_memory.\n\n @see ic4_propmap_deserialize_from_memory\n @see ic4_propmap_serialize_to_file"]
    pub fn ic4_propmap_serialize_to_memory(
        map: *mut IC4_PROPERTY_MAP,
        alloc: ic4_serialization_allocator,
        ppData: *mut *mut ::std::os::raw::c_void,
        data_size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Restores the state of the properties in this property map from a file that was previously written by #ic4_propmap_serialize_to_file.\n\n @param[in]\tmap\t\tA property map\n @param[in]\tpath\tPath to a file that was previously written by #ic4_propmap_serialize_to_file\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @note\n If the file contains settings for properties that could not be written, the function fails and the error value is set to #IC4_ERROR_INCOMPLETE.\n\n @see ic4_propmap_serialize_to_file"]
    pub fn ic4_propmap_deserialize_from_file(
        map: *mut IC4_PROPERTY_MAP,
        path: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn ic4_propmap_deserialize_from_fileW(map: *mut IC4_PROPERTY_MAP, path: *const u16)
        -> bool;
}
extern "C" {
    #[doc = " @brief Restores the state of the properties in this property map from a memory buffer containing data that was previously written by #ic4_propmap_serialize_to_memory.\n\n @param[in]\tmap\t\t\tA property map\n @param[in]\tpData\t\tPointer to a memory buffer containing data that was written by #ic4_propmap_serialize_to_memory\n @param[in]\tdata_size\tSize of the memory buffer pointed to by @c pData\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @note\n If the memory buffer contains settings for properties that could not be written, the function fails and the error value is set to #IC4_ERROR_INCOMPLETE.\n\n @see ic4_propmap_serialize_to_memory"]
    pub fn ic4_propmap_deserialize_from_memory(
        map: *mut IC4_PROPERTY_MAP,
        pData: *const ::std::os::raw::c_void,
        data_size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Increases the property's internal reference count by one.\n\n @param[in] prop A property\n\n @return The pointer passed via \\a prop\n\n @remarks If \\a prop is \\c NULL, the function returns \\c NULL. An error value is not set.\n\n @see ic4_prop_unref"]
    pub fn ic4_prop_ref(prop: *mut IC4_PROPERTY) -> *mut IC4_PROPERTY;
}
extern "C" {
    #[doc = " @brief Decreases the property's internal reference count by one.\n\n If the reference count reaches zero, the object is destroyed.\n\n @param[in] prop A property\n\n @remarks\n If \\a prop is \\c NULL, the function does nothing. An error value is not set.\n\n @see ic4_prop_ref"]
    pub fn ic4_prop_unref(prop: *mut IC4_PROPERTY);
}
extern "C" {
    #[doc = " @brief Returns the type of the passed property\n\n @param[in] prop\tA property\n\n @return\tThe type of the property \\c prop, or #IC4_PROPTYPE_INVALID in case of an error.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @see IC4_PROPERTY_TYPE"]
    pub fn ic4_prop_get_type(prop: *mut IC4_PROPERTY) -> IC4_PROPERTY_TYPE;
}
extern "C" {
    #[doc = " @brief Returns the name of the passed property\n\n @param[in] prop\tA property\n\n @return\tThe name of the passed property, or \\c NULL in case of an error.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\\n\n\t\t\tThe memory pointed to by the return value is valid as long as the property object exists.\n\n @remarks\n A property's name is the symbolic name with which it can be found in a @ref propmap, for example \\c ExposureTime or \\c AcquisitionFrameRate.\n\n @see ic4_prop_get_display_name"]
    pub fn ic4_prop_get_name(prop: *mut IC4_PROPERTY) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Checks whether a property is currently available.\n\n If a property is not available, attempts to read or write its value will fail.\n\n A property may become unavailable, if its value does not have a meaning in the current state of the device.\n The property's availability status can change upon writing to another property.\n\n @param[in] prop\tA property\n\n @return\t\\c true, if the property is currently available, otherwise \\c false.\\n\n\t\t\tIf there is an error, this function returns \\c false. Use ic4_get_last_error() to query error information.\n\n @see ic4_prop_is_locked\n @see ic4_prop_is_readonly"]
    pub fn ic4_prop_is_available(prop: *mut IC4_PROPERTY) -> bool;
}
extern "C" {
    #[doc = " @brief Checks whether a property is currently locked.\n\n A locked property can be read, but attempts to write its value will fail.\n\n A property's locked status may change upon writing to another property.\n\n Common examples for locked properties are \\c ExposureTime or \\c Gain if \\c ExposureAuto or \\c GainAuto are enabled.\n\n @param[in] prop\tA property\n\n @return\t\\c true, if the property is currently locked, otherwise \\c false.\\n\n\t\t\tIf there is an error, this function returns \\c false. Use ic4_get_last_error() to query error information.\n\n @see ic4_prop_is_available\n @see ic4_prop_is_readonly\n @see ic4_prop_is_likely_locked_by_stream"]
    pub fn ic4_prop_is_locked(prop: *mut IC4_PROPERTY) -> bool;
}
extern "C" {
    #[doc = " @brief Tries to determine whether a property is locked because a data stream is active.\n\n @param[in] prop\tA property\n\n @return\t@c true, if the property is currently locked, and will likely be unlocked if the data stream is stopped.\\n\n\t\t\t@c false, if the property is not currently locked, or stopping the data stream will probably not lead to\n\t\t\tthe property being unlocked.\\n\n\t\t\tIf there is an error, this function returns \\c false. Use ic4_get_last_error() to query error information.\n\n @remarks\tFor technical reasons, this function cannot always accurately predict the future.\n\n @see ic4_prop_is_locked"]
    pub fn ic4_prop_is_likely_locked_by_stream(prop: *mut IC4_PROPERTY) -> bool;
}
extern "C" {
    #[doc = " @brief Checks whether a property is read-only.\n\n A read-only property will never be writable, the read-only status will never change.\n\n A Common examples for read-only property is \\c DeviceTemperature.\n\n @param[in] prop\tA property\n\n @return\t\\c true, if the property is read-only, otherwise \\c false.\\n\n\t\t\tIf there is an error, this function returns \\c false. Use ic4_get_last_error() to query error information.\n\n @see ic4_prop_is_available\n @see ic4_prop_is_locked"]
    pub fn ic4_prop_is_readonly(prop: *mut IC4_PROPERTY) -> bool;
}
extern "C" {
    #[doc = " @brief Returns a visibility hint for the property.\n\n The visibility hint can be used to create user interfaces with different complexities. The most commonly used properties\n have the beginner visibility, while rarely used or diagnostic features might be tagged guru or even invisible.\n\n @param[in] prop\tA property\n\n @return\tThe visibility hint for the property.\\n\n\t\t\tIf there is an error, this function returns @ref IC4_PROPVIS_INVISIBLE. Use ic4_get_last_error() to query error information."]
    pub fn ic4_prop_get_visibility(prop: *mut IC4_PROPERTY) -> IC4_PROPERTY_VISIBILITY;
}
extern "C" {
    #[doc = " @brief Returns the display name of the passed property\n\n @param[in] prop\tA property\n\n @return\tThe display name of the passed property, or \\c NULL in case of an error.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\\n\n\t\t\tThe memory pointed to by the return value is valid as long as the property object exists.\n\n @remarks\n A property's display name is a text representation of the property that is meant to be displayed in user interfaces.\\n\n For example, the display name of the \\c ExposureTime property usually is <i>Exposure Time</i>.\n\n @see ic4_prop_get_name"]
    pub fn ic4_prop_get_display_name(prop: *mut IC4_PROPERTY) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Returns a tooltip for the passed property\n\n @param[in] prop\tA property\n\n @return\tThe tooltip for the passed property, or \\c NULL in case of an error.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\\n\n\t\t\tThe memory pointed to by the return value is valid as long as the property object exists.\n\n @remarks\n A property's tooltip is a text that can be used when a tooltip is required by a user interface.\\n\n Usually, the tooltip is a short description of the property.\n\n @see ic4_prop_get_description"]
    pub fn ic4_prop_get_tooltip(prop: *mut IC4_PROPERTY) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Returns a description text for the passed property\n\n @param[in] prop\tA property\n\n @return\tThe description for the passed property, or \\c NULL in case of an error.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\\n\n\t\t\tThe memory pointed to by the return value is valid as long as the property object exists.\n\n @remarks\n A property's description is a short text that describes the property, usually in more detail than the tooltip.\n\n @see ic4_prop_get_tooltip"]
    pub fn ic4_prop_get_description(prop: *mut IC4_PROPERTY) -> *const ::std::os::raw::c_char;
}
#[doc = " @brief Property notification handler function pointer\n\n @param[in] prop\t\tThe property that has changed\n @param[in] user_ptr\tThe user data that was specified when the notification handler was registered\n\n @see ic4_prop_event_add_notification"]
pub type ic4_prop_notification = ::std::option::Option<
    unsafe extern "C" fn(prop: *mut IC4_PROPERTY, user_ptr: *mut ::std::os::raw::c_void),
>;
#[doc = " @brief Property notification deleter\n\n @param[in] user_ptr\tThe user data that was specified when the notification deleter was registered\n\n @see ic4_prop_event_add_notification\n @see ic4_prop_event_remove_notification"]
pub type ic4_prop_notification_deleter =
    ::std::option::Option<unsafe extern "C" fn(user_ptr: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " @brief Registers a property notification handler\n\n The property notification handler is called whenever an aspect of the property changes, for example its value or locked status.\n\n @param[in] prop\t\tA property\n @param[in] handler\tThe property notification handler to be called if \\a prop changes\n @param[in] user_ptr\tUser data to be passed to the notification handler\n @param[in] deleter\tThe property notification deleter to be called if the notification is removed, or the property is destroyed\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n The \\c deleter callback can useful to release resources that the caller passed in into \\c user_ptr.\n\n @remarks\n Multiple notification handlers can be registered for the same property, as long as the \\c user_ptr parameter is different.\n\n @see ic4_prop_event_remove_notification\n @see ic4_prop_notification\n @see ic4_prop_notification_deleter"]
    pub fn ic4_prop_event_add_notification(
        prop: *mut IC4_PROPERTY,
        handler: ic4_prop_notification,
        user_ptr: *mut ::std::os::raw::c_void,
        deleter: ic4_prop_notification_deleter,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Unregisters a previously registered notification handler\n\n @param[in] prop\t\tA property with a registered notification handler\n @param[in] handler\tThe property notification handler to be removed\n @param[in] user_ptr\tThe user data that was specified when the handler was registered\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n The values for \\c handler and \\c user_ptr must exactly match the arguments of the previous successful call to #ic4_prop_event_add_notification().\n\n @see ic4_prop_event_add_notification"]
    pub fn ic4_prop_event_remove_notification(
        prop: *mut IC4_PROPERTY,
        handler: ic4_prop_notification,
        user_ptr: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Indicates whether this property's value changes the meaning and/or value of other properties.\n\n @param[in] prop\t\t\tA property\n\n @return @c true, if @c prop is a selector, otherwise @c false.\\n\n\t\t\tIf an error occurs, the function returns @c false. Use ic4_get_last_error() to query error information.\n\n @see ic4_prop_get_selected"]
    pub fn ic4_prop_is_selector(prop: *mut IC4_PROPERTY) -> bool;
}
extern "C" {
    #[doc = " @brief Returns the list of properties whose values' meaning depend on this property.\n\n @param[in] prop\t\t\tA property that is a selector\n @param[out] ppSelected\tA pointer to a property list receiving the list of properties selected by \\c prop.\n\t\t\t\t\t\t\tWhen the property list is no longer required, release the object reference using #ic4_proplist_unref().\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If \\c prop is not a boolean property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n\n\n @see ic4_prop_is_selector"]
    pub fn ic4_prop_get_selected_props(
        prop: *mut IC4_PROPERTY,
        ppSelected: *mut *mut IC4_PROPERTY_LIST,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Retrieves the list of properties in a property category.\n\n @param[in] prop\t\t\tA category property\n @param[in] ppFeatures\tA pointer to a property list receiving the list of properties inside the category \\c prop.\n\t\t\t\t\t\t\tWhen the property list is no longer required, release the object reference using #ic4_proplist_unref().\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If \\c prop is not a category property, this function returns \\c false and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH."]
    pub fn ic4_prop_category_get_features(
        prop: *mut IC4_PROPERTY,
        ppFeatures: *mut *mut IC4_PROPERTY_LIST,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Execute a command property\n\n @param[in] prop\t\t\tA command property\n\n @return @c true on success, otherwise @c false.\\n\n\t\t\tUse @ref ic4_get_last_error() to query error information.\n\n @remarks\n If \\c prop is not a command property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n"]
    pub fn ic4_prop_command_execute(prop: *mut IC4_PROPERTY) -> bool;
}
extern "C" {
    #[doc = " @brief Checks whether a command has finished executing.\n\n @param prop\t\t\t\tA command property\n @param is_done\t\t\tOutput parameter receiving the command's completion status.\\n\n\t\t\t\t\t\t\t@c true, if the command is completed. @c false, if the command is still executing.\n\n @return @c true on success, otherwise @c false.\\n\n\t\t\tUse @ref ic4_get_last_error() to query error information.\n\n @remarks\n If the command was never executed before, the @a is_done is set to @c false."]
    pub fn ic4_prop_command_is_done(prop: *mut IC4_PROPERTY, is_done: *mut bool) -> bool;
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " @brief Defines the possible integer property representations\n\n Each integer property has a representation hint that can help creating more useful user interfaces."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IC4_PROPERTY_INT_REPRESENTATION {
    #[doc = "< Suggest a slider to edit the value"]
    IC4_PROPINTREP_LINEAR = 0,
    #[doc = "< Suggest a slider with logarithmic mapping"]
    IC4_PROPINTREP_LOGARITHMIC = 1,
    #[doc = "< Suggest a checkbox"]
    IC4_PROPINTREP_BOOLEAN = 2,
    #[doc = "< Suggest displaying a decimal number"]
    IC4_PROPINTREP_PURENUMBER = 3,
    #[doc = "< Suggest displaying a hexadecimal number"]
    IC4_PROPINTREP_HEXNUMBER = 4,
    #[doc = "< Suggest treating the integer as a IPV4 address"]
    IC4_PROPINTREP_IPV4ADDRESS = 5,
    #[doc = "< Suggest treating the integer as a MAC address"]
    IC4_PROPINTREP_MACADDRESS = 6,
}
extern "C" {
    #[doc = " @brief Returns the suggested representation for an integer property.\n\n The representation can be used as a hint when creating user interfaces.\n\n @param[in] prop\tAn integer property\n\n @return\tThe suggested representation for the property, or a default representation in case of an error.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If \\c prop is not an integer property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n\n\n @see IC4_PROPERTY_INT_REPRESENTATION"]
    pub fn ic4_prop_integer_get_representation(
        prop: *mut IC4_PROPERTY,
    ) -> IC4_PROPERTY_INT_REPRESENTATION;
}
extern "C" {
    #[doc = " @brief Returns the unit of an integer property.\n\n @param[in] prop\tAn integer property\n\n @return\tThe unit of the the property. The unit can be an empty string, if there is no unit for the property.\\n\n\t\t\tThe memory pointed to by the return value is valid as long as the property object exists.\\n\n\t\t\tIf an error occurs, the function returns @c NULL. Use ic4_get_last_error() to query error information.\n\n @remarks\n If \\c prop is not an integer property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n"]
    pub fn ic4_prop_integer_get_unit(prop: *mut IC4_PROPERTY) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Changes the value of an integer property.\n\n @param[in] prop\t\t\tAn integer property\n @param[in] value\t\t\tThe new value to set\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If \\c prop is not an integer property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n\n If the device or component rejected the value, the function fails and the error value is set to #IC4_ERROR_GENICAM_VALUE_ERROR. \\n\n If the value is currently not writable, the function fails and the error value is set to #IC4_ERROR_GENICAM_ACCESS_DENIED. \\n\n\n @see ic4_prop_integer_get_min\n @see ic4_prop_integer_get_max\n @see ic4_prop_integer_get_inc"]
    pub fn ic4_prop_integer_set_value(prop: *mut IC4_PROPERTY, value: i64) -> bool;
}
extern "C" {
    #[doc = " @brief Reads the current value of an integer property.\n\n @param[in] prop\t\t\tAn integer property\n @param[out] pValue\t\tPointer to an integer to receive the current value\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If \\c prop is not an integer property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n"]
    pub fn ic4_prop_integer_get_value(prop: *mut IC4_PROPERTY, pValue: *mut i64) -> bool;
}
extern "C" {
    #[doc = " @brief Returns the minimum value accepted by an integer property.\n\n @param[in] prop\t\t\tAn integer property\n @param[out] pMinimum\t\tPointer to an integer to receive the minimum value\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If \\c prop is not an integer property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n\n\n @see ic4_prop_integer_get_max\n @see ic4_prop_integer_get_inc"]
    pub fn ic4_prop_integer_get_min(prop: *mut IC4_PROPERTY, pMinimum: *mut i64) -> bool;
}
extern "C" {
    #[doc = " @brief Returns the maximum value accepted by an integer property.\n\n @param[in] prop\t\t\tAn integer property\n @param[out] pMaximum\t\tPointer to an integer to receive the maximum value\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If \\c prop is not an integer property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n\n\n @see ic4_prop_integer_get_min\n @see ic4_prop_integer_get_inc"]
    pub fn ic4_prop_integer_get_max(prop: *mut IC4_PROPERTY, pMaximum: *mut i64) -> bool;
}
extern "C" {
    #[doc = " @brief Returns the step size for valid values accepted by an integer property.\n\n The increment restricts the set of valid values for an integer property.\n For example, if the property's minimum value is \\c 0, the maximum is \\c 10, and the increment is \\c 2, \\c 5 is not a valid value for the property\n and will be rejected when trying to write it.\n\n @param[in] prop\t\t\tAn integer property\n @param[out] pIncrement\tPointer to an integer to receive the increment\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If \\c prop is not an integer property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n\n\n @see ic4_prop_integer_get_min\n @see ic4_prop_integer_get_max"]
    pub fn ic4_prop_integer_get_inc(prop: *mut IC4_PROPERTY, pIncrement: *mut i64) -> bool;
}
extern "C" {
    #[doc = " @brief Returns how this integer property restricts which values are valid between its minimum and maximum value.\n\n @param[in] prop\tAn integer property\n\n @return\t#IC4_PROPINCMODE_INCREMENT if the property has a fixed step size between valid values.\\n\n\t\t\t#IC4_PROPINCMODE_VALUESET, if the property has a set of valid values.\\n\n\t\t\tIf an error occurs, the function returns #IC4_PROPINCMODE_INCREMENT and the error value is set.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @see ic4_prop_integer_get_inc\n @see ic4_prop_integer_get_valid_value_set"]
    pub fn ic4_prop_integer_get_inc_mode(prop: *mut IC4_PROPERTY) -> IC4_PROPERTY_INCREMENT_MODE;
}
extern "C" {
    #[doc = " @brief Returns the set of valid values for an integer\n\n @param[in] prop\t\t\t\tAn integer property restricted to a set of values\n @param[out] value_set\t\tAn array to receive the set of valid values\n @param[in, out] array_size\tPointer to a @c size_t indicating the length of @c value_set.\\n\n\t\t\t\t\t\t\t\tAfter the call, this contains the number of entries in this property's set of valid values.\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @note\n If @c value_set is not @c NULL and @a array_size is \\c NULL, the function fails and the error value is set to #IC4_ERROR_INVALID_PARAM_VAL.\n If @c *array_size is lower than the number of entries in this property's set of valid values, the function fails the error value is set to #IC4_ERROR_BUFFER_TOO_SMALL.\n If @c prop is not restricted by a set of valid values, the function fails and the error value is set to #IC4_ERROR_GENICAM_NOT_IMPLEMENTED.\n"]
    pub fn ic4_prop_integer_get_valid_value_set(
        prop: *mut IC4_PROPERTY,
        value_set: *mut i64,
        array_size: *mut usize,
    ) -> bool;
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " @brief Defines the possible float property representations\n\n Each float property has a representation hint that can help creating more useful user interfaces."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IC4_PROPERTY_FLOAT_REPRESENTATION {
    #[doc = "< Suggest a slider to edit the value"]
    IC4_PROPFLOATREP_LINEAR = 0,
    #[doc = "< Suggest a slider with logarithmic mapping"]
    IC4_PROPFLOATREP_LOGARITHMIC = 1,
    #[doc = "< Suggest displaying a number"]
    IC4_PROPFLOATREP_PURENUMBER = 2,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " @brief Defines the possible float property display notations\n\n Each float property has a display notation hint that can help creating more useful user interfaces."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IC4_PROPERTY_DISPLAY_NOTATION {
    #[doc = "< Use an automatic mechanism to determine the best display notation"]
    IC4_PROPDISPNOTATION_AUTOMATIC = 0,
    #[doc = "< Suggest fixed point notation"]
    IC4_PROPDISPNOTATION_FIXED = 1,
    #[doc = "< Suggest scientific notation"]
    IC4_PROPDISPNOTATION_SCIENTIFIC = 2,
}
extern "C" {
    #[doc = " @brief Returns the suggested represenation for a float property.\n\n The representation can be used as a hint when creating user interfaces.\n\n @param[in] prop\tA float property\n\n @return\tThe suggested representation for the property, or a default representation in case of an error.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If \\c prop is not a float property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n\n\n @see IC4_PROPERTY_FLOAT_REPRESENTATION"]
    pub fn ic4_prop_float_get_representation(
        prop: *mut IC4_PROPERTY,
    ) -> IC4_PROPERTY_FLOAT_REPRESENTATION;
}
extern "C" {
    #[doc = " @brief Returns the unit of a float property.\n\n @param[in] prop\tA float property\n\n @return\tThe unit of the the property. The unit can be an empty string, if there is no unit for the property.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\\n\n\t\t\tThe memory pointed to by the return value is valid as long as the property object exists.\n\n @remarks\n If \\c prop is not a float property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n"]
    pub fn ic4_prop_float_get_unit(prop: *mut IC4_PROPERTY) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Returns a suggested display notation to use when displaying the float property's value.\n\n @param[in] prop\tA float property\n\n @return\tA display notation suggestion, or @ref IC4_PROPDISPNOTATION_AUTOMATIC if there is an error.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\\n\n\n @remarks\n If \\c prop is not a float property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n"]
    pub fn ic4_prop_float_get_display_notation(
        prop: *mut IC4_PROPERTY,
    ) -> IC4_PROPERTY_DISPLAY_NOTATION;
}
extern "C" {
    #[doc = " @brief Returns a suggested number of significant digits to use when displaying the float property's value.\n\n @param[in] prop\tA float property\n\n @return\tThe suggested number of significant digits for display, or a default value if there is an error.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\\n\n\n @remarks\n If \\c prop is not a float property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n"]
    pub fn ic4_prop_float_get_display_precision(prop: *mut IC4_PROPERTY) -> i64;
}
extern "C" {
    #[doc = " @brief Changes the value of a float property.\n\n @param[in] prop\t\t\tA float property\n @param[in] value\t\t\tThe new value to set\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If \\c prop is not a float property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n\n If the device or component rejected the value, the function fails and the error value is set to #IC4_ERROR_GENICAM_VALUE_ERROR. \\n\n If the value is currently not writable, the function fails and the error value is set to #IC4_ERROR_GENICAM_ACCESS_DENIED. \\n\n\n @see ic4_prop_float_get_min\n @see ic4_prop_float_get_max\n @see ic4_prop_float_get_inc"]
    pub fn ic4_prop_float_set_value(prop: *mut IC4_PROPERTY, value: f64) -> bool;
}
extern "C" {
    #[doc = " @brief Reads the current value of a float property.\n\n @param[in] prop\t\t\tA float property\n @param[out] pValue\t\tPointer to a double to receive the current value\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If \\c prop is not a float property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n"]
    pub fn ic4_prop_float_get_value(prop: *mut IC4_PROPERTY, pValue: *mut f64) -> bool;
}
extern "C" {
    #[doc = " @brief Returns the minimum value accepted by a float property.\n\n @param[in] prop\t\t\tA float property\n @param[out] pMinimum\t\tPointer to an double to receive the minimum value\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If \\c prop is not an float property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n\n\n @see ic4_prop_integer_get_max\n @see ic4_prop_integer_get_inc"]
    pub fn ic4_prop_float_get_min(prop: *mut IC4_PROPERTY, pMinimum: *mut f64) -> bool;
}
extern "C" {
    #[doc = " @brief Returns the maximum value accepted by a float property.\n\n @param[in] prop\t\t\tA float property\n @param[out] pMaximum\t\tPointer to an double to receive the maximum value\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If \\c prop is not an float property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n\n\n @see ic4_prop_integer_get_min\n @see ic4_prop_integer_get_inc"]
    pub fn ic4_prop_float_get_max(prop: *mut IC4_PROPERTY, pMaximum: *mut f64) -> bool;
}
extern "C" {
    #[doc = " @brief Returns how this float property restricts which values are valid between its minimum and maximum value.\n\n @param[in] prop\tA float property\n\n @return\t@ref IC4_PROPINCMODE_INCREMENT, if the property has a fixed step size between valid values.\\n\n\t\t\t@ref IC4_PROPINCMODE_VALUESET, if the property has a set of valid values.\\n\n\t\t\t@ref IC4_PROPINCMODE_NONE, if the property can be set to any value between its minimum and maximum.\\n\n\t\t\tIf an error occurs, the function returns @ref IC4_PROPINCMODE_NONE and the error value is set.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If @c prop is not a float property, the function fails and the error value is set to @ref IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n\n\n @see ic4_prop_float_get_inc\n @see ic4_prop_float_get_valid_value_set"]
    pub fn ic4_prop_float_get_inc_mode(prop: *mut IC4_PROPERTY) -> IC4_PROPERTY_INCREMENT_MODE;
}
extern "C" {
    #[doc = " @brief Returns the step size for valid values accepted by a float property.\n\n The increment restricts the set of valid values for a float property.\n For example, if the property's minimum value is \\c 0.0, the maximum is \\c 1.0, and the increment is \\c 0.5, \\c 1.25 is not a valid value for the property\n and will be rejected when trying to write it.\n\n @param[in] prop\t\t\tA float property\n @param[out] pIncrement\tPointer to a double to receive the increment\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If \\c prop is not a float property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n\n\n @see ic4_prop_float_get_min\n @see ic4_prop_float_get_max\n @see ic4_prop_float_has_inc"]
    pub fn ic4_prop_float_get_inc(prop: *mut IC4_PROPERTY, pIncrement: *mut f64) -> bool;
}
extern "C" {
    #[doc = " @brief Returns the set of valid values for a float\n\n @param[in] prop\t\t\t\tA float property restricted to a set of values\n @param[out] value_set\t\tAn array to receive the set of valid values\n @param[in, out] array_size\tPointer to a @c size_t indicating the length of @c value_set.\\n\n\t\t\t\t\t\t\t\tAfter the call, this contains the number of entries in this property's set of valid values.\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @note\n If @c value_set is not @c NULL and @a array_size is \\c NULL, the function fails and the error value is set to #IC4_ERROR_INVALID_PARAM_VAL.\n If @c *array_size is lower than the number of entries in this property's set of valid values, the function fails the error value is set to #IC4_ERROR_BUFFER_TOO_SMALL.\n If @c prop is not restricted by a set of valid values, the function fails and the error value is set to #IC4_ERROR_GENICAM_NOT_IMPLEMENTED.\n"]
    pub fn ic4_prop_float_get_valid_value_set(
        prop: *mut IC4_PROPERTY,
        value_set: *mut f64,
        array_size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Changes the value of a boolean property.\n\n @param[in] prop\t\t\tAn boolean property\n @param[in] value\t\t\tThe new value to set\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If \\c prop is not a boolean property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n\n If the value is currently not writable, the function fails and the error value is set to #IC4_ERROR_GENICAM_ACCESS_DENIED. \\n"]
    pub fn ic4_prop_boolean_set_value(prop: *mut IC4_PROPERTY, value: bool) -> bool;
}
extern "C" {
    #[doc = " @brief Reads the current value of a boolean property.\n\n @param[in] prop\t\t\tA boolean property\n @param[out] pValue\t\tPointer to a bool to receive the current value\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If \\c prop is not a boolean property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n"]
    pub fn ic4_prop_boolean_get_value(prop: *mut IC4_PROPERTY, pValue: *mut bool) -> bool;
}
extern "C" {
    #[doc = " @brief Reads the current value of a string property.\n\n @param[in] prop\t\t\t\tA string property\n @param[out] buffer\t\t\tPointer to a character array to receive the string value.\\n\n\t\t\t\t\t\t\t\tThis parameter can be \\c NULL to find out the required space without allocating an initial array.\n @param[in, out] buffer_size\tPointer to a \\c size_t describing the length of the array pointed to by \\a buffer.\\n\n\t\t\t\t\t\t\t\tThe function always writes the actual number of characters required to store the string representation.\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If \\c prop is not a string property, the function fails and the error value is set to @ref IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n\n If \\c buffer is not \\c NULL, and \\c *buffer_size is less than the length of the value of this property, the function fails and the error value is set to @ref IC4_ERROR_BUFFER_TOO_SMALL. \\n"]
    pub fn ic4_prop_string_get_value(
        prop: *mut IC4_PROPERTY,
        buffer: *mut ::std::os::raw::c_char,
        buffer_size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Changes the value of a string property.\n\n @param[in] prop\t\t\tA string property\n @param[in] buffer\t\tPointer to a buffer containing the new string value\n @param[in] buffer_size\tLength of \\c buffer.\\n\n\t\t\t\t\t\t\tIf \\c 0, interpret \\c buffer as a null-terminated string.\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If \\c prop is not a string property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n\n If the value is currently not writable, the function fails and the error value is set to #IC4_ERROR_GENICAM_ACCESS_DENIED. \\n"]
    pub fn ic4_prop_string_set_value(
        prop: *mut IC4_PROPERTY,
        buffer: *const ::std::os::raw::c_char,
        buffer_size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns the maximum length of the string that can be stored in this property.\n\n @param[in] prop\t\t\tA string property\n @param[out] pMaxLength\tPointer to an integer to receive the maximum length of the string value of this property\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If \\c prop is not a string property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n"]
    pub fn ic4_prop_string_get_max_len(prop: *mut IC4_PROPERTY, pMaxLength: *mut u64) -> bool;
}
extern "C" {
    #[doc = " @brief Returns the list of entries in this enumeration property.\n\n @param[in] prop\t\t\tAn enumeration property\n @param[out] ppList\t\tA pointer to a property list receiving the list of enumeration entries.\\n\n\t\t\t\t\t\t\tWhen the property list is no longer required, release the object reference using #ic4_proplist_unref().\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If \\c prop is not an enumeration property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n"]
    pub fn ic4_prop_enum_get_entries(
        prop: *mut IC4_PROPERTY,
        ppList: *mut *mut IC4_PROPERTY_LIST,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Finds the enumeration entry with a given name in this enumeration property.\n\n @param[in] prop\t\t\tAn enumeration property\n @param[in] entry_name\tThe name of one of this enumeration property's enumeration entries\n @param[out] ppEntry\t\tA pointer to a property receiving the requested enumeration entry.\\n\n\t\t\t\t\t\t\tWhen the enumeration entry is no longer required, release the object reference using #ic4_prop_unref().\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If \\c prop is not an enumeration property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n\n\n @see ic4_prop_enum_find_entry_by_value"]
    pub fn ic4_prop_enum_find_entry_by_name(
        prop: *mut IC4_PROPERTY,
        entry_name: *const ::std::os::raw::c_char,
        ppEntry: *mut *mut IC4_PROPERTY,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Finds the enumeration entry with a given value in this enumeration property.\n\n @param[in] prop\t\t\tAn enumeration property\n @param[in] entry_value\tThe value of one of this enumeration property's enumeration entries\n @param[out] ppEntry\t\tA pointer to a property receiving the requested enumeration entry.\\n\n\t\t\t\t\t\t\tWhen the enumeration entry is no longer required, release the object reference using #ic4_prop_unref().\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If \\c prop is not an enumeration property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n\n\n @see ic4_prop_enum_find_entry_by_name"]
    pub fn ic4_prop_enum_find_entry_by_value(
        prop: *mut IC4_PROPERTY,
        entry_value: i64,
        ppEntry: *mut *mut IC4_PROPERTY,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sets the enumeration's selected entry by name.\n\n @param[in] prop\t\t\tAn enumeration property\n @param[in] entry_name\tThe name of an enumeration entry of @c prop.\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If @c prop is not an enumeration property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n\n If @c entry_name is not the name of an entry of @c prop, the function fails and the error value is set to #IC4_ERROR_GENICAM_VALUE_ERROR. \\n\n\n @see ic4_prop_enum_set_selected_entry\n @see ic4_prop_enum_set_int_value"]
    pub fn ic4_prop_enum_set_value(
        prop: *mut IC4_PROPERTY,
        entry_name: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns the name of the currently selected entry of the enumeration.\n\n @param prop\t\t\t\tAn enumeration property\n\n @return\tThe name of the enumeration's currently selected entry, or \\c NULL in case of an error.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\\n\n\t\t\tThe memory pointed to by the return value is valid at least as the property object exists,\n\t\t\tor until the next call to @c ic4_prop_enum_get_value on this enumeration.\n\n @remarks\n If @c prop is not an enumeration property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH."]
    pub fn ic4_prop_enum_get_value(prop: *mut IC4_PROPERTY) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Sets the enumeration's selected entry.\n\n @param[in] prop\t\tAn enumeration property\n @param[in] entry\t\tAn enumeration entry of @c prop.\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If @c prop is not an enumeration property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n\n If @c entry is not an enumeration entry property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n\n If @c entry is not an enumeration entry of @c prop, the function fails and the error value is set to #IC4_ERROR_GENICAM_VALUE_ERROR. \\n\n\n @see ic4_prop_enum_set_value\n @see ic4_prop_enum_set_int_value"]
    pub fn ic4_prop_enum_set_selected_entry(
        prop: *mut IC4_PROPERTY,
        entry: *mut IC4_PROPERTY,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns the currently selected entry of this enumeration property.\n\n @param[in] prop\t\t\tAn enumeration property\n @param[out] ppEntry\t\tA pointer to a property receiving the currently selected enumeration entry.\\n\n\t\t\t\t\t\t\tWhen the enumeration entry is no longer required, release the object reference using #ic4_prop_unref().\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If \\c prop is not an enumeration property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n\n\n @see ic4_prop_enum_get_int_value"]
    pub fn ic4_prop_enum_get_selected_entry(
        prop: *mut IC4_PROPERTY,
        ppEntry: *mut *mut IC4_PROPERTY,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Selects the currently selected entry of this enumeration property by specifying the entry's value.\n\n This method can be useful to directly set a known enumeration entry, for example setting the \\c PixelFormat to @ref IC4_PIXEL_FORMAT_Mono8.\n\n @param[in] prop\t\t\tAn enumeration property\n @param[in] entry_value\tThe value of an enumeration entry of \\c prop.\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If \\c prop is not an enumeration property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n\n\n @see ic4_prop_enum_set_selected_entry\n @see ic4_prop_enum_get_int_value"]
    pub fn ic4_prop_enum_set_int_value(prop: *mut IC4_PROPERTY, entry_value: i64) -> bool;
}
extern "C" {
    #[doc = " @brief Returns the value of the currently selected entry of an enumeration property.\n\n @param[in] prop\t\t\tAn enumeration property\n @param[out] pValue\t\tA pointer to a double receiving the currently selected enumeration entry's value\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If \\c prop is not an enumeration property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n\n\n @see ic4_prop_enum_get_selected_entry\n @see ic4_prop_enum_set_int_value"]
    pub fn ic4_prop_enum_get_int_value(prop: *mut IC4_PROPERTY, pValue: *mut i64) -> bool;
}
extern "C" {
    #[doc = " @brief Returns the value of an enumeration entry.\n\n @param[in] prop\t\t\tAn enumeration entry\n @param[out] pValue\t\tA pointer to a double receiving the value of the enumeration entry\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If \\c prop is not an enumeration entry, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n\n\n @see ic4_prop_enum_get_entries"]
    pub fn ic4_prop_enumentry_get_int_value(prop: *mut IC4_PROPERTY, pValue: *mut i64) -> bool;
}
extern "C" {
    #[doc = " @brief Queries the size of a register property.\n\n The size of a register property is not necessarily constant; it can change depending on the value of other properties.\n\n @param[in] prop\t\tA register property\n @param[out] pSize\tPointer to a @c uint64_t to receive the data size of the register in bytes.\n\n @remarks\n If \\c prop is not a register property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information."]
    pub fn ic4_prop_register_get_size(prop: *mut IC4_PROPERTY, pSize: *mut u64) -> bool;
}
extern "C" {
    #[doc = " @brief Reads data from a register property.\n\n @param[in]\tprop\t\tA register property\n @param[out]\tbuffer\t\tA buffer receiving the data from the property\n @param[in]\tbuffer_size Size of @c buffer in bytes. Must be equal to the size of the register property.\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If \\c prop is not a register property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n\n If @c buffer_size is not equal to the size of the property returned from #ic4_prop_register_get_size(), the function fails and the error value is set to #IC4_ERROR_INVALID_PARAM_VAL.\\n\n\n @see ic4_prop_register_get_size\n @see ic4_prop_register_set_value"]
    pub fn ic4_prop_register_get_value(
        prop: *mut IC4_PROPERTY,
        buffer: *mut ::std::os::raw::c_void,
        buffer_size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Writes data to a register property.\n\n @param[in]\tprop\t\tA register property\n @param[in]\tbuffer\t\tA buffer containing the data to be written to the property\n @param[in]\tbuffer_size\tSize of @c buffer in bytes. Must be equal to the size of the register property.\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If @c prop is not a register property, the function fails and the error value is set to #IC4_ERROR_GENICAM_TYPE_MISMATCH. \\n\n If @c buffer_size is not equal to the size of the property returned from #ic4_prop_register_get_size(), the function fails and the error value is set to #IC4_ERROR_INVALID_PARAM_VAL.\\n\n\n @see ic4_prop_register_get_size\n @see ic4_prop_register_get_value"]
    pub fn ic4_prop_register_set_value(
        prop: *mut IC4_PROPERTY,
        buffer: *const ::std::os::raw::c_void,
        buffer_size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Increases the property list's internal reference count by one.\n\n @param[in] list\tA property list\n\n @return The pointer passed via \\c list\n\n @remarks If \\c list is \\c NULL, the function returns \\c NULL. An error value is not set.\n\n @see ic4_proplist_unref"]
    pub fn ic4_proplist_ref(list: *mut IC4_PROPERTY_LIST) -> *mut IC4_PROPERTY_LIST;
}
extern "C" {
    #[doc = " @brief Decreases the property list's internal reference count by one.\n\n If the reference count reaches zero, the object is destroyed.\n\n @param[in] list\tA property list\n\n @remarks\n If \\c list is \\c NULL, the function does nothing. An error value is not set.\n\n @see ic4_proplist_ref"]
    pub fn ic4_proplist_unref(list: *mut IC4_PROPERTY_LIST);
}
extern "C" {
    #[doc = " @brief Returns the number of properties in a property list.\n\n @param[in] list\tA property list\n @param[out] size\tPointer to a \\c size_t to receive the number of properties in \\c list.\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information."]
    pub fn ic4_proplist_size(list: *mut IC4_PROPERTY_LIST, size: *mut usize) -> bool;
}
extern "C" {
    #[doc = " @brief Returns a property from a property list.\n\n @param[in] list\t\t\tA property list\n @param[in] index\t\t\tIndex of the property to retrieve from \\c list\n @param[out]\tppProperty\tPointer to a handle receiving the property object.\\n\n\t\t\t\t\t\t\tWhen the property is no longer required, release the object reference using #ic4_prop_unref().\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information."]
    pub fn ic4_proplist_at(
        list: *mut IC4_PROPERTY_LIST,
        index: usize,
        ppProperty: *mut *mut IC4_PROPERTY,
    ) -> bool;
}
#[doc = " \\struct IC4_DEVICE_ENUM\n Device enumerator type.\n\n Call ic4_devenum_create() to create a device enumerator object.\n\n This type is reference-counted. Call ic4_devenum_ref() to increase the internal reference count,\n or ic4_devenum_unref() to decrease it. If the reference count reaches zero, the object is destroyed.\n\n After ic4_devenum_update_device_list() has been called, ic4_devenum_get_device_count() returns the number\n of detected devices.\n\n Use ic4_devenum_get_devinfo() to get a #IC4_DEVICE_INFO object providing information about one of the\n devices.\n\n @see ic4_devenum_create"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IC4_DEVICE_ENUM {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Creates a new device enumerator\n\n @param[out] ppEnumerator A pointer to receive a pointer to the new device enumerator.\\n\n                          When the enumerator is no longer required, release the object reference\n                          using ic4_devenum_unref().\n\n @return \\c true on success, otherwise \\c false. Use ic4_get_last_error() to query error information.\n\n @see ic4_devenum_unref"]
    pub fn ic4_devenum_create(ppEnumerator: *mut *mut IC4_DEVICE_ENUM) -> bool;
}
extern "C" {
    #[doc = " Increases the device enumerator's internal reference count by one.\n\n @param[in] pEnumerator A pointer to a device enumerator\n\n @return The pointer passed via \\a pEnumerator\n\n @remarks If \\a pEnumerator is \\c NULL, the function returns \\c NULL. An error value is not set.\n\n @see ic4_devenum_unref"]
    pub fn ic4_devenum_ref(pEnumerator: *mut IC4_DEVICE_ENUM) -> *mut IC4_DEVICE_ENUM;
}
extern "C" {
    #[doc = " Decreases the device enumerator's internal reference count by one.\n\n If the reference count reaches zero, the object is destroyed.\n\n @param[in] pEnumerator A pointer to a device enumerator\n\n @remarks If \\a pEnumerator is \\c NULL, the function does nothing. An error value is not set.\n\n @see ic4_devenum_ref"]
    pub fn ic4_devenum_unref(pEnumerator: *mut IC4_DEVICE_ENUM);
}
extern "C" {
    #[doc = " Searches for video capture devices and populates the enumerator's internal device list.\n\n @param[in] pEnumerator A pointer to a device enumerator\n\n @return \\c true on success, otherwise \\c false. Use ic4_get_last_error() to query error information.\n\n @see ic4_devenum_get_device_count\n @see ic4_devenum_get_devinfo"]
    pub fn ic4_devenum_update_device_list(pEnumerator: *mut IC4_DEVICE_ENUM) -> bool;
}
extern "C" {
    #[doc = " Returns the number of devices discovered by the previous call to ic4_devenum_update_device_list().\n\n @param[in] pEnumerator A pointer to a device enumerator\n\n @return The number of devices in the enumerator's internal device list\\n\n         If an error occurs, the function returns 0. ic4_get_last_error() can query error information.\n\n @see ic4_devenum_get_devinfo"]
    pub fn ic4_devenum_get_device_count(
        pEnumerator: *const IC4_DEVICE_ENUM,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\struct IC4_DEVICE_INFO\n Device information type.\n\n Instances of this type are created by calling ic4_devenum_get_devinfo().\n\n This type is reference-counted. Call ic4_devinfo_ref() to increase the internal reference count,\n or ic4_devinfo_unref() to decrease it. If the reference count reaches zero, the object is destroyed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IC4_DEVICE_INFO {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Returns a #IC4_DEVICE_INFO object describing one of the discovered video capture devices.\n\n @param[in] pEnumerator\tA pointer to a device enumerator\n @param[in] index\t\t\tList position of the device whose information is to be retrieved\n @param[out] ppInfo\t\tA pointer to receive a pointer to the a #IC4_DEVICE_INFO object.\\n\n\t\t\t\t\t\t\tWhen the device information object is no longer required, release the reference\n\t\t\t\t\t\t\tusing ic4_devenum_unref().\n\n @return \\c true on success, otherwise \\c false.\n\n @remarks ic4_devenum_update_device_list() has to be called before this function can return anything useful.\n          Use ic4_devenum_get_device_count() to determine the maximum valid value for \\a index.\n\n @see ic4_devinfo_unref"]
    pub fn ic4_devenum_get_devinfo(
        pEnumerator: *const IC4_DEVICE_ENUM,
        index: ::std::os::raw::c_int,
        ppInfo: *mut *mut IC4_DEVICE_INFO,
    ) -> bool;
}
extern "C" {
    #[doc = " Searches for interfaces and populates the enumerator's internal interface list.\n\n @param[in] pEnumerator A pointer to a device enumerator\n\n @return \\c true on success, otherwise \\c false. Use ic4_get_last_error() to query error information.\n\n @remarks Using the interface enumeration is entirely optional; for many use cases searching for devices\n\tvia ic4_devenum_update_device_list() is sufficient.\n\n @see ic4_devenum_get_interface_count\n @see ic4_devenum_get_devitf"]
    pub fn ic4_devenum_update_interface_list(pEnumerator: *mut IC4_DEVICE_ENUM) -> bool;
}
extern "C" {
    #[doc = " Returns the number of interfaces discovered by the previous call to ic4_devenum_update_interface_list().\n\n @param[in] pEnumerator A pointer to a device enumerator\n\n @return The number of interfaces in the enumerator's internal interface list\\n\n         If an error occurs, the function returns 0. ic4_get_last_error() can query error information.\n\n @see ic4_devenum_get_devitf"]
    pub fn ic4_devenum_get_interface_count(
        pEnumerator: *const IC4_DEVICE_ENUM,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\struct IC4_INTERFACE\n Device interface type.\n\n Interfaces represent physical connections for cameras to the computer, e.g. network adapters or USB controllers.\n\n Instances of this type are created by calling ic4_devenum_get_devitf().\n\n This type is reference-counted. Call ic4_devitf_ref() to increase the internal reference count,\n or ic4_devitf_unref() to decrease it. If the reference count reaches zero, the object is destroyed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IC4_INTERFACE {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Returns a #IC4_INTERFACE object describing one of the discovered interfaces.\n\n @param[in] pEnumerator\tA pointer to a device enumerator\n @param[in] index\t\t\tList position of the interface to be opened\n @param[out] ppInterface\tA pointer to receive a pointer to the a #IC4_INTERFACE object.\\n\n                          When the interface object is no longer required, release the reference\n                          using ic4_devitf_unref().\n\n @return \\c true on success, otherwise \\c false.\n\n @remarks ic4_devenum_update_interface_list() has to be called before this function can return anything useful.\n          Use ic4_devenum_get_interface_count() to determine the maximum valid value for \\a index.\n\n @see ic4_devinfo_unref"]
    pub fn ic4_devenum_get_devitf(
        pEnumerator: *const IC4_DEVICE_ENUM,
        index: ::std::os::raw::c_int,
        ppInterface: *mut *mut IC4_INTERFACE,
    ) -> bool;
}
#[doc = " Function pointer for the device-list-changed handler\n\n @param[in] pDevEnum\tPointer to the device enumerator on which the callback was registered\n @param[in] user_ptr\tUser data that was specified when calling #ic4_devenum_event_add_device_list_changed()"]
pub type ic4_devenum_device_list_change_handler = ::std::option::Option<
    unsafe extern "C" fn(pDevEnum: *mut IC4_DEVICE_ENUM, user_ptr: *mut ::std::os::raw::c_void),
>;
#[doc = " Function pointer for cleanup of the device-list-changed user data\n\n @param[in] user_ptr\tUser data that was specified when calling #ic4_devenum_event_add_device_list_changed()"]
pub type ic4_devenum_device_list_change_deleter =
    ::std::option::Option<unsafe extern "C" fn(user_ptr: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " Registers a function to be called when the list of available video capture devices has (potentially) changed\n\n @param[in] pEnumerator\tThe device enumerator for which the callback is registered\n @param[in] handler\t\tThe function to be called when the list of available video capture devices has changed\n @param[in] user_ptr\t\tUser data to be passed in calls to \\a handler.\n @param[in] deleter\t\tA function to be called when the handler was unregistered and the user_ptr will no longer be required.\\n\n\t\t\t\t\t\t\tThe deleter function can be used to release data associated with \\a user_ptr.\\n\n\t\t\t\t\t\t\tThe \\a deleter function will be called when the device-list-changed handler is unregistered,\n\t\t\t\t\t\t\tor the device enumerator object itself is destroyed.\n\n @note\n To unregister a device-list-changed handler, call #ic4_devenum_event_remove_device_list_changed().\\n\n It is not guaranteed that every call to @a handler correlates to an actual change in the device list.\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information."]
    pub fn ic4_devenum_event_add_device_list_changed(
        pEnumerator: *mut IC4_DEVICE_ENUM,
        handler: ic4_devenum_device_list_change_handler,
        user_ptr: *mut ::std::os::raw::c_void,
        deleter: ic4_devenum_device_list_change_deleter,
    ) -> bool;
}
extern "C" {
    #[doc = " Unregisters a device-list-changed handler that was previously registered using #ic4_devenum_event_add_device_list_changed().\n\n @param[in] pEnumerator\tThe device enumerator for which the callback is currently registered\n @param[in] handler\t\tPointer to the function to be unregistered\n @param[in] user_ptr\t\tUser data that the function was previously registered with\n\n @note\n The pair of \\a handler and \\a user_ptr has to be an exact match to the parameters used in the call to #ic4_devenum_event_add_device_list_changed().\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information."]
    pub fn ic4_devenum_event_remove_device_list_changed(
        pEnumerator: *mut IC4_DEVICE_ENUM,
        handler: ic4_devenum_device_list_change_handler,
        user_ptr: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Increases the device interface's internal reference count by one.\n\n @param[in] pInterface A pointer to a device interface\n\n @return The pointer passed via \\a pInterface\n\n @remarks If \\a pInterface is \\c NULL, the function returns \\c NULL. An error value is not set.\n\n @see ic4_devitf_unref"]
    pub fn ic4_devitf_ref(pInterface: *mut IC4_INTERFACE) -> *mut IC4_INTERFACE;
}
extern "C" {
    #[doc = " Decreases the device interface's internal reference count by one.\n\n If the reference count reaches zero, the object is destroyed.\n\n @param[in] pInterface A pointer to a device interface\n\n @remarks If \\a pInterface is \\c NULL, the function does nothing. An error value is not set.\n\n @see ic4_devitf_ref"]
    pub fn ic4_devitf_unref(pInterface: *mut IC4_INTERFACE);
}
extern "C" {
    #[doc = " Returns the name of the device interface.\n\n @param[in] pInterface A pointer to a device interface\n\n @return\tA null-terminated string containing the device interface's name.\\n\n\t\t\tThe memory pointed to by the returned pointer is valid as long as the interface object exists.\\n\n\t\t\tIf an error occurs, the function returns @c NULL. Use ic4_get_last_error() to query error information."]
    pub fn ic4_devitf_get_display_name(
        pInterface: *const IC4_INTERFACE,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Returns the name of the transport layer that provides this interface object.\n\n This string can be interpreted as a name for the driver providing access to devices on the interface.\n\n @param[in] pInterface\tA pointer to a device interface\n\n @return\tA null-terminated string containing the transport layer name.\\n\n\t\t\tThe memory pointed to by the returned pointer is valid as long as the interface object exists.\\n\n\t\t\tIf an error occurs, the function returns @c NULL. Use ic4_get_last_error() to query error information."]
    pub fn ic4_devitf_get_tl_name(
        pInterface: *const IC4_INTERFACE,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Returns the version of the transport layer that provides this interface object.\n\n This string can be interpreted as driver version for the driver providing access devices on the interface.\n\n @param[in] pInterface\tA pointer to a device interface\n\n @return\tA null-terminated string containing the transport layer verision.\\n\n\t\t\tThe memory pointed to by the returned pointer is valid as long as the interface object exists.\\n\n\t\t\tIf an error occurs, the function returns @c NULL. Use ic4_get_last_error() to query error information."]
    pub fn ic4_devitf_get_tl_version(
        pInterface: *const IC4_INTERFACE,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " @brief Contains the possible transport layer types."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IC4_TL_TYPE {
    #[doc = "< Other or unknown transport layer type"]
    IC4_TLTYPE_UNKNOWN = 0,
    #[doc = "< The transport layer uses the GigE Vision standard"]
    IC4_TLTYPE_GIGEVISION = 1,
    #[doc = "< The transport layer uses the USB3 Vision standard"]
    IC4_TLTYPE_USB3VISION = 2,
}
extern "C" {
    #[doc = " @brief Returns the type of the transport layer used by this interface.\n\n @param[in] pInterface\tA pointer to a device interface\n\n @return\tA #IC4_TL_TYPE value describing the type of the transport layer."]
    pub fn ic4_devitf_get_tl_type(pInterface: *const IC4_INTERFACE) -> IC4_TL_TYPE;
}
extern "C" {
    #[doc = " Opens the property map for the specified device interface.\n\n The property map can be used to query advanced interface information or configure the interface and its attached devices.\n\n @param[in] pInterface A pointer to a device interface\n @param[out] ppMap     A pointer to a pointer to a #IC4_PROPERTY_MAP object.\\n\n                       When the property map is no longer required, release the reference using ic4_propmap_unref().\n\n @return \\c true on success, otherwise \\c false. Use ic4_get_last_error() to query error information."]
    pub fn ic4_devitf_get_property_map(
        pInterface: *const IC4_INTERFACE,
        ppMap: *mut *mut IC4_PROPERTY_MAP,
    ) -> bool;
}
extern "C" {
    #[doc = " Searches for video capture devices and populates the device interfaces's internal device list.\n\n @param[in] pInterface A pointer to a device interface\n\n @return \\c true on success, otherwise \\c false. Use ic4_get_last_error() to query error information.\n\n @see ic4_devitf_get_device_count\n @see ic4_devitf_get_devinfo"]
    pub fn ic4_devitf_update_device_list(pInterface: *mut IC4_INTERFACE) -> bool;
}
extern "C" {
    #[doc = " Returns the number of devices discovered by the previous call to ic4_devitf_update_device_list().\n\n @param[in] pInterface A pointer to a device interface\n\n @return The number of devices in the inferface's internal device list\\n\n         If an error occurs, the function returns 0. ic4_get_last_error() can query error information.\n\n @see ic4_devitf_get_devinfo"]
    pub fn ic4_devitf_get_device_count(pInterface: *const IC4_INTERFACE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns a #IC4_DEVICE_INFO object describing one of the discovered video capture devices.\n\n @param[in] pInterface\tA pointer to a device interface\n @param[in] index\t\t\tList position of the device whose information is to be retrieved\n @param[out] ppInfo\t\tA pointer to receive a pointer to the a #IC4_DEVICE_INFO object.\\n\n\t\t\t\t\t\t\tWhen the device information object is no longer required, release the reference\n\t\t\t\t\t\t\tusing ic4_devenum_unref().\n\n @return \\c true on success, otherwise \\c false.\n\n @remarks ic4_devitf_update_device_list() has to be called before this function can return anything useful.\n          Use ic4_devitf_get_device_count() to determine the maximum valid value for \\a index.\n\n @see ic4_devinfo_unref"]
    pub fn ic4_devitf_get_devinfo(
        pInterface: *const IC4_INTERFACE,
        index: ::std::os::raw::c_int,
        ppInfo: *mut *mut IC4_DEVICE_INFO,
    ) -> bool;
}
extern "C" {
    #[doc = " Checks whether two device interface objects refer to the same interface.\n\n @param[in] pInterface1 First interface object\n @param[in] pInterface2 Second interface object\n\n @return\n    \\c true if the device interface objects refer to the same interface, otherwise \\c false.\\n\n    If both pointers are NULL, the function returns \\c true."]
    pub fn ic4_devitf_equals(
        pInterface1: *const IC4_INTERFACE,
        pInterface2: *const IC4_INTERFACE,
    ) -> bool;
}
extern "C" {
    #[doc = " Increases the device information's internal reference count by one.\n\n @param[in] pInfo A pointer to a device information object\n\n @return The pointer passed via \\a pInfo\n\n @remarks If \\a pInfo is \\c NULL, the function returns \\c NULL. An error value is not set.\n\n @see ic4_devinfo_unref"]
    pub fn ic4_devinfo_ref(pInfo: *mut IC4_DEVICE_INFO) -> *mut IC4_DEVICE_INFO;
}
extern "C" {
    #[doc = " Decreases the device information's internal reference count by one.\n\n If the reference count reaches zero, the object is destroyed.\n\n @param[in] pInfo A pointer to a device information object\n\n @remarks If \\a pInfo is \\c NULL, the function does nothing. An error value is not set.\n\n @see ic4_devenum_ref"]
    pub fn ic4_devinfo_unref(pInfo: *mut IC4_DEVICE_INFO);
}
extern "C" {
    #[doc = " Get the model name from a device information object.\n\n @param[in] pInfo A pointer to a device information object\n\n @return\n    A pointer to a null-terminated string containing the device's model name, or \\c NULL if an error occured.\\n\n    Use ic4_get_last_error() to query error information.\\n\n    The memory pointed to by the return value is valid as long as the device information object exists."]
    pub fn ic4_devinfo_get_model_name(
        pInfo: *const IC4_DEVICE_INFO,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the textual representation of the serial number from a device information object.\n\n @param[in] pInfo A pointer to a device information object\n\n @return\n    A pointer to a null-terminated string containing the device's serial number, or \\c NULL if an error occured.\\n\n    Use ic4_get_last_error() to query error information.\\n\n    The memory pointed to by the return value is valid as long as the device information object exists.\\n\n\t  The format of the serial number string is device-specific.\n"]
    pub fn ic4_devinfo_get_serial(pInfo: *const IC4_DEVICE_INFO) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the device version from a device information object.\n\n @param[in] pInfo A pointer to a device information object\n\n @return\n    A pointer to a null-terminated string containing the device's version information, or \\c NULL if an error occured.\\n\n    Use ic4_get_last_error() to query error information.\\n\n    The memory pointed to by the return value is valid as long as the device information object exists.\\n\n\t  The format of the device version is device-specific."]
    pub fn ic4_devinfo_get_version(pInfo: *const IC4_DEVICE_INFO) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the device's user-defined identifier from a device information object.\n\n @param[in] pInfo A pointer to a device information object\n\n @return\n    A pointer to a null-terminated string containing the device's user-defined identifier, or \\c NULL if an error occured.\\n\n    Use ic4_get_last_error() to query error information.\\n\n    The memory pointed to by the return value is valid as long as the device information object exists.\n\n @remarks\n    If supported by the device, the device's user-defined identifier can be configured through the @c DeviceUserID feature\n    in the device's property map."]
    pub fn ic4_devinfo_get_user_id(pInfo: *const IC4_DEVICE_INFO) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the device's unique name from a device information object.\n\n @param[in] pInfo A pointer to a device information object\n\n @return\n    A pointer to a null-terminated string containing the device's unique name, or \\c NULL if an error occured.\\n\n    Use ic4_get_last_error() to query error information.\\n\n    The memory pointed to by the return value is valid as long as the device information object exists.\\n\n\t  The unique name consists of an identifier for the device driver and the device's serial number,\n    allowing devices to be uniquely identified by a single string."]
    pub fn ic4_devinfo_get_unique_name(
        pInfo: *const IC4_DEVICE_INFO,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Checks whether two device information objects refer to the same video capture device.\n\n @param[in] pInfo1 First device info\n @param[in] pInfo2 Second device info\n\n @return\n    \\c true if the device information objects refer to the same video capture device, otherwise \\c false.\\n\n    If both pointers are NULL, the function returns \\c true."]
    pub fn ic4_devinfo_equals(
        pInfo1: *const IC4_DEVICE_INFO,
        pInfo2: *const IC4_DEVICE_INFO,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns the interface the device represented by the device information object is attached to.\n\n @param[in] pInfo\t\t\tA device information object\n @param[out] ppInterface\tA pointer to receive a pointer to the a #IC4_INTERFACE object.\\n\n\t\t\t\t\t\t\tWhen the interface object is no longer required, release the reference\n\t\t\t\t\t\t\tusing ic4_devitf_unref().\n\n @return \\c true on success, otherwise \\c false. Use ic4_get_last_error() to query error information."]
    pub fn ic4_devinfo_get_devitf(
        pInfo: *const IC4_DEVICE_INFO,
        ppInterface: *mut *mut IC4_INTERFACE,
    ) -> bool;
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " @brief Defines the possible display types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IC4_DISPLAY_TYPE {
    #[doc = " @brief Selects the platform's default display type.\n\n For Windows, this is IC4_DISPLAY_WIN32_OPENGL."]
    IC4_DISPLAY_DEFAULT = 0,
    #[doc = " @brief Optimized OpenGL display for Windows platform"]
    IC4_DISPLAY_WIN32_OPENGL = 1,
}
#[doc = " @struct IC4_DISPLAY\n @brief Represents a display that can be used to display images.\n\n This type is opaque, programs only use pointers of type \\c IC4_DISPLAY*.\n\n To create a display, use @ref ic4_display_create() or @ref ic4_display_create_external_opengl().\n\n Display objects are generally used in two distinct ways:\n -\tThe display is connected to a data stream when calling @ref ic4_grabber_stream_setup(),\n\t\tautomatically displaying all images from the opened device.\n -\t@ref IC4_IMAGE_BUFFER objects are displayed manually by calling @ref ic4_display_display_buffer().\n\n Display objects are reference-counted. The initial reference count is one.\n\n To share a display object between multiple parts of a program, use ic4_display_ref().\n Call ic4_display_unref() when a reference is no longer required.\n If the reference count reaches zero, the display object is destroyed.\n\n @note\n Some functions, such as @ref ic4_grabber_stream_setup(), share ownership of the display object passed as an argument.\n The display object is kept alive by the #IC4_GRABBER instance even if no external references exist.\n\n @see ic4_display_create\n @see ic4_display_ref\n @see ic4_display_unref"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IC4_DISPLAY {
    _unused: [u8; 0],
}
pub type IC4_WINDOW_HANDLE = *mut ::std::os::raw::c_void;
#[doc = " @brief A structure containing display statistics\n\n This structure contains information about the number of frames that were\n displayed or dropped by a display."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IC4_DISPLAY_STATS {
    #[doc = " @brief The number of frames that were displayed by a display"]
    pub num_frames_displayed: u64,
    #[doc = " @brief The number of frames that were passed to a display, but not displayed\n\n A frame is considered dropped by a display, when the display receives a new frame\n before the previous frame was rendered."]
    pub num_frames_dropped: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IC4_DISPLAY_STATS"][::std::mem::size_of::<IC4_DISPLAY_STATS>() - 16usize];
    ["Alignment of IC4_DISPLAY_STATS"][::std::mem::align_of::<IC4_DISPLAY_STATS>() - 8usize];
    ["Offset of field: IC4_DISPLAY_STATS::num_frames_displayed"]
        [::std::mem::offset_of!(IC4_DISPLAY_STATS, num_frames_displayed) - 0usize];
    ["Offset of field: IC4_DISPLAY_STATS::num_frames_dropped"]
        [::std::mem::offset_of!(IC4_DISPLAY_STATS, num_frames_dropped) - 8usize];
};
extern "C" {
    #[doc = " @brief Creates a new display.\n\n @param[in] type The type of display to create\n @param[in] parent Handle to the parent window to embed the display into.\n @param[out] ppDisplay Pointer to receive the handle to the new display object.\\n\n             When the display is no longer required, release the object reference using ic4_display_unref().\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @warning\n This function only works in Windows platforms. For other platforms, use @ref ic4_display_create_external_opengl().\n\n @see ic4_display_unref"]
    pub fn ic4_display_create(
        type_: IC4_DISPLAY_TYPE,
        parent: IC4_WINDOW_HANDLE,
        ppDisplay: *mut *mut IC4_DISPLAY,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Creates a new external OpenGL display\n\n @param[out]\t\t\tppDisplay Pointer to receive the handle to the new display object.\\n\n\t\t\t\t\t\tWhen the display is no longer required, release the object reference using ic4_display_unref().\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n To use the external renderer, the application has to follow these steps:\n - Create an OpenGL window, typically using the UI toolkit of the application\n - Call @ref ic4_display_external_opengl_initialize with the OpenGL context activated for the active thread\n - Repeatedly call @ref ic4_display_external_opengl_render with the OpenGL context activated for the active thread\n\n @see ic4_display_unref"]
    pub fn ic4_display_create_external_opengl(ppDisplay: *mut *mut IC4_DISPLAY) -> bool;
}
extern "C" {
    #[doc = " @brief Increases the display's internal reference count by one.\n\n @param[in] pDisplay A pointer to a display\n\n @return The pointer passed via \\a pDisplay\n\n @remarks If \\a pDisplay is \\c NULL, the function returns \\c NULL. An error value is not set.\n\n @see ic4_display_unref"]
    pub fn ic4_display_ref(pDisplay: *mut IC4_DISPLAY) -> *mut IC4_DISPLAY;
}
extern "C" {
    #[doc = " @brief Decreases the display's internal reference count by one.\n\n If the reference count reaches zero, the object is destroyed.\n\n @param[in] pDisplay A pointer to a display\n\n @remarks If \\a pDisplay is \\c NULL, the function does nothing. An error value is not set.\n\n @see ic4_display_ref"]
    pub fn ic4_display_unref(pDisplay: *mut IC4_DISPLAY);
}
extern "C" {
    #[doc = " @brief Displays a specific image buffer.\n\n @param[in] pDisplay A display\n @param[in] buffer The buffer to display\n\n @remarks It is not always necessary to call this function.\\n\n\t\t\tWhen a display is registered with a #IC4_GRABBER using ic4_grabber_set_display(), images are displayed automatically.\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n When @a buffer is @c NULL, the display is cleared and will no longer display the previous buffer."]
    pub fn ic4_display_display_buffer(
        pDisplay: *mut IC4_DISPLAY,
        buffer: *const IC4_IMAGE_BUFFER,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Queries statistics about a display\n\n @param[in] pDisplay\tA display\n @param[out] stats\tPointer to a #IC4_DISPLAY_STATS structure receiving statistics about the display\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information."]
    pub fn ic4_display_get_stats(pDisplay: *mut IC4_DISPLAY, stats: *mut IC4_DISPLAY_STATS)
        -> bool;
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " @brief Contains the possible display alignment and stretch modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IC4_DISPLAY_RENDER_POSITION {
    #[doc = "< Display images unscaled at the top left corner of the window"]
    IC4_DISPLAY_RENDER_POSITION_TOPLEFT = 0,
    #[doc = "< Display images unscaled an the center of the window"]
    IC4_DISPLAY_RENDER_POSITION_CENTER = 1,
    #[doc = "< Display images stretched at the top left corner of the window"]
    IC4_DISPLAY_RENDER_POSITION_STRETCH_TOPLEFT = 2,
    #[doc = "< Display images stretched at the center of the window"]
    IC4_DISPLAY_RENDER_POSITION_STRETCH_CENTER = 3,
    #[doc = "< Display images at custom coordinates"]
    IC4_DISPLAY_RENDER_POSITION_CUSTOM = 4,
}
extern "C" {
    #[doc = " @brief Configure the image scaling and alignment options for a display.\n\n @param[in] pDisplay\tA display\n @param[in] pos\t\tThe scaling and alignment mode to use\n @param[in] left\t\tThe left coordinate of the target rectangle inside the display window\n @param[in] top\t\tThe top coordinate of the target rectangle inside the display window\n @param[in] width\t\tThe width of the target rectangle inside the display window\n @param[in] height\tThe height of the target rectangle inside the display window\n\n @remarks\n The \\a left, \\a top, \\a width and \\a height parameters are ignored unless \\a pos is \\c IC4_DISPLAY_RENDER_POSITION_CUSTOM.\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information."]
    pub fn ic4_display_set_render_position(
        pDisplay: *mut IC4_DISPLAY,
        pos: IC4_DISPLAY_RENDER_POSITION,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> bool;
}
#[doc = " Function pointer for the window-closed handler\n\n @param[in] pDisplay\tPointer to the display whose window was closed\n @param[in] user_ptr\tUser data that was specified when calling #ic4_display_event_add_window_closed()"]
pub type ic4_display_window_closed_handler = ::std::option::Option<
    unsafe extern "C" fn(pDisplay: *mut IC4_DISPLAY, user_ptr: *mut ::std::os::raw::c_void),
>;
#[doc = " Function pointer for cleanup of the device-lost user data\n\n @param[in] user_ptr\tUser data that was specified when calling #ic4_grabber_event_add_device_lost()"]
pub type ic4_display_window_closed_deleter =
    ::std::option::Option<unsafe extern "C" fn(user_ptr: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " @brief Registers a callback to be called when the display is closed.\n\n @param[in] pDisplay\tA display\n @param[in] handler\tThe function to be called when the display is closed\n @param[in] user_ptr\tUser data to be passed in calls to \\a handler.\n @param[in] deleter\tA function to be called when the handler was unregistered and the user_ptr will no longer be required.\\n\n\t\t\t\t\t\tThe deleter function can be used to release data associated with \\a user_ptr.\\n\n\t\t\t\t\t\tThe \\a deleter function will be called when the display-closed handler is unregistered,\n\t\t\t\t\t\tor the display object itself is destroyed.\n\n @note\n To unregister a display-closed handler, call #ic4_display_event_remove_window_closed().\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information."]
    pub fn ic4_display_event_add_window_closed(
        pDisplay: *mut IC4_DISPLAY,
        handler: ic4_display_window_closed_handler,
        user_ptr: *mut ::std::os::raw::c_void,
        deleter: ic4_display_window_closed_deleter,
    ) -> bool;
}
extern "C" {
    #[doc = " Unregisters a display-closed handler that was previously registered using #ic4_display_event_add_window_closed().\n\n @param[in] pDisplay\tThe display on which the callback is currently registered\n @param[in] handler\tPointer to the function to be unregistered\n @param[in] user_ptr\tUser data that the function was previously registered with\n\n @note\n The pair of \\a handler and \\a user_ptr has to be an exact match to the parameters used in the call to #ic4_display_event_add_window_closed().\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information."]
    pub fn ic4_display_event_remove_window_closed(
        pDisplay: *mut IC4_DISPLAY,
        handler: ic4_display_window_closed_handler,
        user_ptr: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Initialize the external OpenGL display\n\n @param[in] pDisplay\tThe external OpenGL display\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse @ref ic4_get_last_error() to query error information.\n\n @remarks\n This function must be called with the OpenGL context activated for the executing thread (e.g. @c makeCurrent)."]
    pub fn ic4_display_external_opengl_initialize(pDisplay: *mut IC4_DISPLAY) -> bool;
}
extern "C" {
    #[doc = " @brief Updates the external OpenGL display with the latest image available.\n\n @param[in] pDisplay\tThe external OpenGL display\n @param[in] width\t\tWidth of the display window in physical pixels\n @param[in] height\tHeight of the display window in physical pixels\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse @ref ic4_get_last_error() to query error information.\n\n @remarks\n This function must be called with the OpenGL context activated for the executing thread (e.g. @c makeCurrent)."]
    pub fn ic4_display_external_opengl_render(
        pDisplay: *mut IC4_DISPLAY,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Notifies the external OpenGL display component that the window has been closed.\n\n @param[in] pDisplay\tThe external OpenGL display\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse @ref ic4_get_last_error() to query error information."]
    pub fn ic4_display_external_opengl_notify_window_closed(pDisplay: *mut IC4_DISPLAY) -> bool;
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " @brief Contains the possible error codes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IC4_ERROR {
    #[doc = "< No error occurred, the operation was successful."]
    IC4_ERROR_NOERROR = 0,
    #[doc = "< An unknown error occurred."]
    IC4_ERROR_UNKNOWN = 1,
    #[doc = "< An internal error (bug) occurred."]
    IC4_ERROR_INTERNAL = 2,
    #[doc = "< The operation is not valid in the current state."]
    IC4_ERROR_INVALID_OPERATION = 3,
    #[doc = "< Out of memory."]
    IC4_ERROR_OUT_OF_MEMORY = 4,
    #[doc = "< InitLibrary has not been not called."]
    IC4_ERROR_LIBRARY_NOT_INITIALIZED = 5,
    #[doc = "< Device driver behaved unexpectedly."]
    IC4_ERROR_DRIVER_ERROR = 6,
    #[doc = "< An invalid parameter was passed in."]
    IC4_ERROR_INVALID_PARAM_VAL = 7,
    #[doc = "< The operation would require an image format conversion that is not supported."]
    IC4_ERROR_CONVERSION_NOT_SUPPORTED = 8,
    #[doc = "< The requested data is not available"]
    IC4_ERROR_NO_DATA = 9,
    #[doc = "< No matching GenICam feature found."]
    IC4_ERROR_GENICAM_FEATURE_NOT_FOUND = 101,
    #[doc = "< Error occured writing to device."]
    IC4_ERROR_GENICAM_DEVICE_ERROR = 102,
    #[doc = "< Attempted an operation on the wrong node type, e.g. command_execute on an integer."]
    IC4_ERROR_GENICAM_TYPE_MISMATCH = 103,
    #[doc = "< Tried to access a camera feature that is currently not accessible."]
    IC4_ERROR_GENICAM_ACCESS_DENIED = 106,
    #[doc = "< Tried to access a feature that is not implemented by the current camera."]
    IC4_ERROR_GENICAM_NOT_IMPLEMENTED = 107,
    #[doc = "< Tried to set an invalid value, e.g. out of range."]
    IC4_ERROR_GENICAM_VALUE_ERROR = 108,
    #[doc = "< Tried to read a value that is only available if chunk data is connected to the property map."]
    IC4_ERROR_GENICAM_CHUNKDATA_NOT_CONNECTED = 109,
    #[doc = "< A supplied buffer was too small to receive all available data."]
    IC4_ERROR_BUFFER_TOO_SMALL = 50,
    #[doc = "< Tried to call a sink type-specific function on an instance of a different sink type."]
    IC4_ERROR_SINK_TYPE_MISMATCH = 52,
    #[doc = "< A snap operation was not completed, because the camera was stopped before all requested frames could be captured."]
    IC4_ERROR_SNAP_ABORTED = 53,
    #[doc = "< Failed to write data to a file."]
    IC4_ERROR_FILE_FAILED_TO_WRITE_DATA = 201,
    #[doc = "< Failed to write to a file, because the location was not writable."]
    IC4_ERROR_FILE_ACCESS_DENIED = 202,
    #[doc = "< Failed to write to a file, because the path was invalid."]
    IC4_ERROR_FILE_PATH_NOT_FOUND = 203,
    #[doc = "< Failed to read data from a file."]
    IC4_ERROR_FILE_FAILED_TO_READ_DATA = 204,
    #[doc = "< The device has become invalid (e. g. it was unplugged)."]
    IC4_ERROR_DEVICE_INVALID = 13,
    #[doc = "< The device was not found."]
    IC4_ERROR_DEVICE_NOT_FOUND = 16,
    #[doc = "< The device behaved unexpectedly."]
    IC4_ERROR_DEVICE_ERROR = 17,
    #[doc = "< The parameter did not uniquely identify an item."]
    IC4_ERROR_AMBIGUOUS = 18,
    #[doc = "< There was an error parsing the parameter or file."]
    IC4_ERROR_PARSE_ERROR = 21,
    #[doc = "< The requested operation could not be completed before the timeout expired."]
    IC4_ERROR_TIMEOUT = 27,
    #[doc = "< The operation was only partially successful, e.g. not all properties of the grabber could be restored."]
    IC4_ERROR_INCOMPLETE = 34,
    #[doc = "< Sink is not yet connected."]
    IC4_ERROR_SINK_NOT_CONNECTED = 38,
    #[doc = "< The passed buffer does not have the expected ImageType."]
    IC4_ERROR_IMAGETYPE_MISMATCH = 39,
    #[doc = "< The sink passed in is already attached to another graph."]
    IC4_ERROR_SINK_ALREADY_ATTACHED = 40,
    #[doc = "< The sink's connect handler signaled an error."]
    IC4_ERROR_SINK_CONNECT_ABORTED = 41,
    #[doc = "< Attempted to register the same notification handler twice."]
    IC4_ERROR_HANDLER_ALREADY_REGISTERED = 60,
    #[doc = "< Attempted to use a non-existing notification handler."]
    IC4_ERROR_HANDLER_NOT_FOUND = 61,
}
extern "C" {
    #[doc = " @brief Query information about the error of the previous library function call\n\n @param[out] pError Pointer to a #IC4_ERROR value to receive the error code.\n @param[out] message Pointer to a character array to receive an error message.<br>\n This parameter is optional and may be \\c NULL.\n @param[in,out] message_length Pointer to a \\c size_t describing the length of the array pointed to by \\a message.<br>\n If \\a message is not \\c NULL, this parameter is required.<br>\n The function always writes the actual number of characters required to store the error message.\n\n @return \\c true on success.\n @return If \\a pError is \\c NULL, the function fails and returns \\c false.\n @return If \\a message is not \\c NULL and \\a message_length is \\c NULL, the function fails and returns \\c false.\n @return If \\a *message_length is lower than the number of characters required to store the error message, the function fails and returns \\c false.\n\n @note\n The last error information is stored in a thread-local way. A call to \\c ic4_get_last_error\n returns error information about the previous function call that happened on the same thread\n that \\c ic4_get_last_error is called from.\n\n @note\n An error while calling \\c ic4_get_last_error does not update the internally stored last error."]
    pub fn ic4_get_last_error(
        pError: *mut IC4_ERROR,
        message: *mut ::std::os::raw::c_char,
        message_length: *mut usize,
    ) -> bool;
}
#[doc = " @struct IC4_GRABBER\n\n @brief Represents an opened video capture device, allowing device configuration and stream setup.\n\n The grabber object is the core component used when working with video capture devices.\n\n This type is opaque, programs only use pointers of type \\c IC4_GRABBER*.\n\n Grabber objects are reference-counted, and created with an initial reference count of one.\n To share a grabber object between multiple parts of a program, create a new reference by calling #ic4_grabber_ref().\n When a reference is no longer required, call #ic4_grabber_unref().\n\n If the grabber object's internal reference count reaches zero, the grabber object is destroyed.\n\n @note\n Some object references, e.g. #IC4_IMAGE_BUFFER, can keep the device and/or driver opened as long as they exist,\n since they point into device driver memory. To free all device-related resources, all objects references have to be released by calling\n their unref-function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IC4_GRABBER {
    _unused: [u8; 0],
}
#[doc = " @struct IC4_SINK\n\n @brief Represents a sink, allowing programmatic access to image data.\n\n This type is opaque, programs only use pointers of type \\c IC4_SINK*.\n\n The \\c IC4_SINK* handle type is used for all sink types, there is no type casting required.\n The actual type of a sink object can be examined by a call to #ic4_sink_get_type().\n\n Sink objects are reference-counted, and created with an initial reference count of one.\n To share a sink object between multiple parts of a program, create a new reference by calling #ic4_sink_ref().\n When a reference is no longer required, call #ic4_sink_unref().\n\n If the sink object's internal reference count reaches zero, the sink object is destroyed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IC4_SINK {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Creates a new grabber.\n\n @param[out] ppGrabber Pointer to receive the handle to the new grabber object.\\n\n             When the grabber is no longer required, release the object reference using #ic4_grabber_unref().\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @see ic4_grabber_unref"]
    pub fn ic4_grabber_create(ppGrabber: *mut *mut IC4_GRABBER) -> bool;
}
extern "C" {
    #[doc = " @brief Increases the grabber's internal reference count by one.\n\n @param[in] pGrabber A pointer to a grabber\n\n @return The pointer passed via \\a pGrabber\n\n @remarks If \\a pGrabber is \\c NULL, the function returns \\c NULL. An error value is not set.\n\n @see ic4_grabber_unref"]
    pub fn ic4_grabber_ref(pGrabber: *mut IC4_GRABBER) -> *mut IC4_GRABBER;
}
extern "C" {
    #[doc = " @brief Decreases the grabber's internal reference count by one.\n\n If the reference count reaches zero, the object is destroyed.\n\n @param[in] pGrabber A pointer to a grabber\n\n @remarks\n If \\a pGrabber is \\c NULL, the function does nothing. An error value is not set.\n\n @remarks\n If the grabber object is destroyed, all its resources are released:\n\t- If image acquisition is active, it is stopped.\n\t- If a data stream was set up, it is stopped.\n  - References to data stream-related objects are released, possibly destroying the sink and/or display.\n  - The device is closed. @ref properties objects become invalid.\n\n @see ic4_grabber_ref"]
    pub fn ic4_grabber_unref(pGrabber: *mut IC4_GRABBER);
}
extern "C" {
    #[doc = " @brief Opens the video capture device specified by the passed #IC4_DEVICE_INFO.\n\n @param[in] pGrabber\tA grabber instance that does not have an opened video capture device\n @param[in] dev\t\tA #IC4_DEVICE_INFO representing the video capture device to be opened\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If the grabber already has a device open, the function will fail and the error value is set to @ref IC4_ERROR_INVALID_OPERATION.\n\n @see ic4_grabber_open_dev_by_name\n @see ic4_grabber_device_close\n @see ic4_grabber_is_device_open\n @see ic4_grabber_is_device_valid"]
    pub fn ic4_grabber_device_open(pGrabber: *mut IC4_GRABBER, dev: *mut IC4_DEVICE_INFO) -> bool;
}
extern "C" {
    #[doc = " @brief Opens the video capture matching the specified identifier.\n\n @param[in] pGrabber\t\tA grabber instance that does not have an opened video capture device\n @param[in] identifier\tThe model name, unique name, serial, user id, IPV4 address or MAC address of a connected video capture device\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If the grabber already has a device open, the function will fail and the error value is set to #IC4_ERROR_INVALID_OPERATION. \\n\n If there are multiple devices matching the specified identifier, the function will fail and the error value is set to #IC4_ERROR_AMBIGUOUS. \\n\n If there is no device with the specified identifier, the function will fail and the error value is set to #IC4_ERROR_DEVICE_NOT_FOUND. \\n\n\n @see ic4_grabber_device_open\n @see ic4_grabber_device_close\n @see ic4_grabber_is_device_open\n @see ic4_grabber_is_device_valid"]
    pub fn ic4_grabber_device_open_by_identifier(
        pGrabber: *mut IC4_GRABBER,
        identifier: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns information about the currently opened video capture device.\n\n @param[in] pGrabber\tA grabber instance with an opened video capture device\n @param[out] ppDev\tA pointer to a handle to receive the device information.\\n\n\t\t\t\t\t\tWhen the device information is no longer required, release the object reference using #ic4_devinfo_unref().\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If the grabber does not have an opened video capture device, the function will fail and the error value is set to #IC4_ERROR_INVALID_OPERATION.\\n\n\n @see ic4_grabber_is_device_open"]
    pub fn ic4_grabber_get_device(
        pGrabber: *mut IC4_GRABBER,
        ppDev: *mut *mut IC4_DEVICE_INFO,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Checks whether the grabber currently has an opened video capture device.\n\n @param[in] pGrabber\tA grabber object\n\n @return \\c true, if the grabber has an opened video capture device, otherwise \\c false.\n\n @remarks\n This function neither clears nor sets the error status returned by ic4_get_last_error().\n\n @see ic4_grabber_device_open"]
    pub fn ic4_grabber_is_device_open(pGrabber: *mut IC4_GRABBER) -> bool;
}
extern "C" {
    #[doc = " @brief Checks whether the grabber's currently opened video capture device is ready to use.\n\n @param[in] pGrabber\tA grabber object\n\n @return \\c true, if the grabber has an opened video capture device that is ready to use, otherwise \\c false.\n\n @remarks\n This function neither clears nor sets the error status returned by ic4_get_last_error().\\n\n There are multiple reasons for why this function may return \\c false:\n\t- No device has been opened\n\t- The device was disconnected\n\t- There is a loose hardware connection\n\t- There was an internal error in the video capture device\n\t- There was a driver error"]
    pub fn ic4_grabber_is_device_valid(pGrabber: *mut IC4_GRABBER) -> bool;
}
extern "C" {
    #[doc = " @brief Closes the video capture device currently opened by this grabber instance\n\n @param[in] pGrabber\tA grabber with an opened video capture device\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n If the device is closed, all its resources are released:\n\t- If image acquisition is active, it is stopped.\n\t- If a data stream was set up, it is stopped.\n  - References to data stream-related objects are released, possibly destroying the sink and/or display.\n  - @ref properties objects become invalid.\n"]
    pub fn ic4_grabber_device_close(pGrabber: *mut IC4_GRABBER) -> bool;
}
extern "C" {
    #[doc = " @brief Returns the property map for the currently opened video capture device.\n\n The property map returned from this function is the origin for all device feature manipulation operations.\n\n @param[in] pGrabber\t\t\tA grabber with an opened video capture device\n @param[out] ppPropertyMap\tPointer to a handle that receives the property map.\\n\n\t\t\t\t\t\t\t\tWhen the property map is longer required, call #ic4_propmap_unref().\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n The property map handle and dependent objects retrieved from it will not keep the device in an opened state.\n If the device is closed, all future operations on the property map will result in an error.\n\n @see ic4_propmap_unref"]
    pub fn ic4_grabber_device_get_property_map(
        pGrabber: *mut IC4_GRABBER,
        ppPropertyMap: *mut *mut IC4_PROPERTY_MAP,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns the property map for the driver of the currently opened video capture device.\n\n The property map returned from this function is the origin for driver-related feature operations.\n\n @param[in] pGrabber\t\t\tA grabber with an opened video capture device\n @param[out] ppPropertyMap\tPointer to a handle that receives the property map.\\n\n\t\t\t\t\t\t\t\tWhen the property map is longer required, call #ic4_propmap_unref().\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @remarks\n The property map handle and dependent objects retrieved from it will not keep the device in an opened state.\n If the device is closed, all future operations on the property map will result in an error.\n\n @see ic4_propmap_unref"]
    pub fn ic4_grabber_driver_get_property_map(
        pGrabber: *mut IC4_GRABBER,
        ppPropertyMap: *mut *mut IC4_PROPERTY_MAP,
    ) -> bool;
}
extern "C" {
    #[doc = " Establishes the data stream from the device.\n\n A data stream is required for image acquisition from the video capture device, and must include a sink (@ref sink), a @ref display, or both.\n\n @param[in] pGrabber\t\t\tA grabber object that has opened a video capture device\n @param[in] sink\t\t\t\tA sink (@ref sink) to receive the images\n @param[in] display\t\t\tA @ref display to display images\n @param[in] start_acquisition\tIf \\c true, immediately start image acquisition after the data stream was set up.\\n\n\t\t\t\t\t\t\t\tOtherwise, a call to #ic4_grabber_acquisition_start() is required to start image acquisition later.\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @pre\n A device was previously opened using #ic4_grabber_device_open() or one of its sibling functions.\n\n @note\n The grabber takes references to the passed sink and display, tying their lifetime to the grabber until the data stream is stopped.\n\n @see ic4_grabber_stream_stop\n @see ic4_grabber_acquisition_start"]
    pub fn ic4_grabber_stream_setup(
        pGrabber: *mut IC4_GRABBER,
        sink: *mut IC4_SINK,
        display: *mut IC4_DISPLAY,
        start_acquisition: bool,
    ) -> bool;
}
extern "C" {
    #[doc = " Stops a data stream that was previously set up by a call to #ic4_grabber_stream_setup().\n\n @param[in] pGrabber\tA grabber with an established data stream\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @note\n This function releases the sink and display references that were passed to #ic4_grabber_stream_setup().\\n\n If there are no external references to the sink or display, the sind or display is destroyed.\n\n @see ic4_grabber_stream_setup"]
    pub fn ic4_grabber_stream_stop(pGrabber: *mut IC4_GRABBER) -> bool;
}
extern "C" {
    #[doc = " Checks whethere there is a data stream established from this grabber's video capture device.\n\n @param[in] pGrabber\tA grabber object\n\n @return\t\\c true, if a data stream was previously established by calling #ic4_grabber_stream_setup().\\n\n\t\t\tOtherwise, or if the data stream was stopped again, \\c false.\n\n @remarks\n This function neither clears nor sets the error status returned by ic4_get_last_error().\n\n @see ic4_grabber_stream_setup\n @see ic4_grabber_stream_stop"]
    pub fn ic4_grabber_is_streaming(pGrabber: *mut IC4_GRABBER) -> bool;
}
extern "C" {
    #[doc = " Starts the acquisition of images from the video capture device.\n\n @param[in] pGrabber\tA grabber with an established data stream\n\n @return\t\\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @pre A data stream has was previously established using #ic4_grabber_stream_setup().\n\n @note\n This operation is equivalent to executing the \\c AcquisitionStart command on the video capture device's property map.\n\n @see ic4_grabber_acquisition_stop\n @see ic4_grabber_stream_setup"]
    pub fn ic4_grabber_acquisition_start(pGrabber: *mut IC4_GRABBER) -> bool;
}
extern "C" {
    #[doc = " Stops the acquisition of images from the video capture device.\n\n @param[in] pGrabber\tA grabber with acquisition active\n\n @return\t\\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @note\n This operation is equivalent to executing the \\c AcquisitionStop command on the video capture device's property map.\n\n @see ic4_grabber_acquisition_start"]
    pub fn ic4_grabber_acquisition_stop(pGrabber: *mut IC4_GRABBER) -> bool;
}
extern "C" {
    #[doc = " Checks whether image acquisition is currently enabled for this grabber's video capture device.\n\n @param[in] pGrabber\tA grabber object\n\n @return\t\\c true, if image acquisition is currently active, otherwise \\c false.\n\n @remarks\n This function neither clears nor sets the error status returned by @ref ic4_get_last_error.\n\n @see ic4_grabber_acquisition_start\n @see ic4_grabber_acquisition_stop"]
    pub fn ic4_grabber_is_acquisition_active(pGrabber: *mut IC4_GRABBER) -> bool;
}
extern "C" {
    #[doc = " Returns a reference to the \\ref sink object that was passed to #ic4_grabber_stream_setup()\n when setting up the currently established data stream.\n\n @param[in] pGrabber\tA grabber with an established data stream\n @param[out] ppSink\tA pointer to a sink handle to receive the currently connected sink.\\n\n\t\t\t\t\t\tThis is a new reference. If it is no longer in use, it must be released using #ic4_sink_unref().\n\n @return\t\\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @see ic4_grabber_stream_setup"]
    pub fn ic4_grabber_get_sink(pGrabber: *mut IC4_GRABBER, ppSink: *mut *mut IC4_SINK) -> bool;
}
extern "C" {
    #[doc = " Returns a reference to the \\ref display object that was passed to #ic4_grabber_stream_setup()\n when setting up the currently established data stream.\n\n @param[in] pGrabber\t\tA grabber with an established data stream\n @param[out] ppDisplay\tA pointer to a sink handle to receive the currently connected display.\\n\n\t\t\t\t\t\t\tThis is a new reference. If it is no longer in use, it must be released using #ic4_display_unref().\n\n @return\t\\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @see ic4_grabber_stream_setup"]
    pub fn ic4_grabber_get_display(
        pGrabber: *mut IC4_GRABBER,
        ppDisplay: *mut *mut IC4_DISPLAY,
    ) -> bool;
}
#[doc = " Function pointer for the device-lost handler\n\n @param[in] pGrabber\tPointer to the grabber whose device was lost\n @param[in] user_ptr\tUser data that was specified when calling #ic4_grabber_event_add_device_lost()"]
pub type ic4_grabber_device_lost_handler = ::std::option::Option<
    unsafe extern "C" fn(pGrabber: *mut IC4_GRABBER, user_ptr: *mut ::std::os::raw::c_void),
>;
#[doc = " Function pointer for cleanup of the device-lost user data\n\n @param[in] user_ptr\tUser data that was specified when calling #ic4_grabber_event_add_device_lost()"]
pub type ic4_grabber_device_lost_deleter =
    ::std::option::Option<unsafe extern "C" fn(user_ptr: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " Registers a function to be called when the currently opened video capture device was disconnected.\n\n @param[in] pGrabber\tThe grabber for which the callback is registered\n @param[in] handler\tThe function to be called when the device is lost\n @param[in] user_ptr\tUser data to be passed in calls to \\a handler.\n @param[in] deleter\tA function to be called when the handler was unregistered and the user_ptr will no longer be required.\\n\n\t\t\t\t\t\tThe deleter function can be used to release data associated with \\a user_ptr.\\n\n\t\t\t\t\t\tThe \\a deleter function will be called when the device-lost handler is unregistered,\n\t\t\t\t\t\tor the grabber object itself is destroyed.\n\n @note\n To unregister a device-lost handler, call #ic4_grabber_event_remove_device_lost().\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information."]
    pub fn ic4_grabber_event_add_device_lost(
        pGrabber: *mut IC4_GRABBER,
        handler: ic4_grabber_device_lost_handler,
        user_ptr: *mut ::std::os::raw::c_void,
        deleter: ic4_grabber_device_lost_deleter,
    ) -> bool;
}
extern "C" {
    #[doc = " Unregisters a device-lost handler that was previously registered using #ic4_grabber_event_add_device_lost().\n\n @param[in] pGrabber\tThe grabber on which the callback is currently registered\n @param[in] handler\tPointer to the function to be unregistered\n @param[in] user_ptr\tUser data that the function was previously registered with\n\n @note\n The pair of \\a handler and \\a user_ptr has to be an exact match to the parameters used in the call to #ic4_grabber_event_add_device_lost().\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information."]
    pub fn ic4_grabber_event_remove_device_lost(
        pGrabber: *mut IC4_GRABBER,
        handler: ic4_grabber_device_lost_handler,
        user_ptr: *mut ::std::os::raw::c_void,
    ) -> bool;
}
#[doc = " @brief Contains statistics counters that can be used to analyze the stream behavior and identify possible bottlenecks.\n\n This structure is filled by calling #ic4_grabber_get_stream_stats()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IC4_STREAM_STATS {
    #[doc = "< Number of frames delivered by the device"]
    pub device_delivered: u64,
    #[doc = "< Number of frames dropped because of transmission errors, e.g. unrecoverable packet loss"]
    pub device_transmission_error: u64,
    #[doc = "< Number of frames dropped by the device driver, because there was no free image buffer available"]
    pub device_underrun: u64,
    #[doc = "< Number of frames delivered by the transform element"]
    pub transform_delivered: u64,
    #[doc = "< Number of frames dropped by the transform element, because there was no free image buffer available"]
    pub transform_underrun: u64,
    #[doc = "< Number of frames processed by the sink"]
    pub sink_delivered: u64,
    #[doc = "< Number of frames dropped by the sink, because there was no free image buffer available"]
    pub sink_underrun: u64,
    #[doc = "< Number of frames ignored by the sink, because the sink was disabled or not instructed to process the data"]
    pub sink_ignored: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IC4_STREAM_STATS"][::std::mem::size_of::<IC4_STREAM_STATS>() - 64usize];
    ["Alignment of IC4_STREAM_STATS"][::std::mem::align_of::<IC4_STREAM_STATS>() - 8usize];
    ["Offset of field: IC4_STREAM_STATS::device_delivered"]
        [::std::mem::offset_of!(IC4_STREAM_STATS, device_delivered) - 0usize];
    ["Offset of field: IC4_STREAM_STATS::device_transmission_error"]
        [::std::mem::offset_of!(IC4_STREAM_STATS, device_transmission_error) - 8usize];
    ["Offset of field: IC4_STREAM_STATS::device_underrun"]
        [::std::mem::offset_of!(IC4_STREAM_STATS, device_underrun) - 16usize];
    ["Offset of field: IC4_STREAM_STATS::transform_delivered"]
        [::std::mem::offset_of!(IC4_STREAM_STATS, transform_delivered) - 24usize];
    ["Offset of field: IC4_STREAM_STATS::transform_underrun"]
        [::std::mem::offset_of!(IC4_STREAM_STATS, transform_underrun) - 32usize];
    ["Offset of field: IC4_STREAM_STATS::sink_delivered"]
        [::std::mem::offset_of!(IC4_STREAM_STATS, sink_delivered) - 40usize];
    ["Offset of field: IC4_STREAM_STATS::sink_underrun"]
        [::std::mem::offset_of!(IC4_STREAM_STATS, sink_underrun) - 48usize];
    ["Offset of field: IC4_STREAM_STATS::sink_ignored"]
        [::std::mem::offset_of!(IC4_STREAM_STATS, sink_ignored) - 56usize];
};
extern "C" {
    #[doc = " @brief Query statistics counters from the currently running or previously stopped data stream.\n\n @param[in] pGrabber\tA grabber object\n @param[out] stats\tA pointer to a structure to receive the stream statistics\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @pre This operation is only valid after a data stream was established once."]
    pub fn ic4_grabber_get_stream_stats(
        pGrabber: *mut IC4_GRABBER,
        stats: *mut IC4_STREAM_STATS,
    ) -> bool;
}
#[doc = " @brief Callback function called to allocate memory during the call of #ic4_grabber_device_save_state.\n\n @param[in]\tsize\tSize of the memory buffer to be allocated.\n\n @return\t\tThe pointer to the allocated memory buffer, or @c NULL if the allocation was not possible.\n\n @note\n If this function returns @c NULL, the call to #ic4_grabber_device_save_state will fail.\n\n @see ic4_grabber_device_save_state"]
pub type ic4_device_state_allocator =
    ::std::option::Option<unsafe extern "C" fn(size: usize) -> *mut ::std::os::raw::c_void>;
extern "C" {
    #[doc = " @brief Saves the currently opened video capture device and all its settings into a memory buffer.\n\n @param[in]\tpGrabber\tA grabber object with an opened device\n @param[in]\talloc\t\tPointer to a function that allocates the memory buffer.\\n\n\t\t\t\t\t\t\tFor example, @c malloc can be passed here.\n @param[out]\tppData\t\tPointer to a pointer to receive the newly-allocated memory buffer containing the device state.\\n\n\t\t\t\t\t\t\tThe caller is responsible for releasing the memory, using a function that can free memory returned by @c alloc.\n @param[out]\tdata_size\tPointer to size_t to receive the size of the memory buffer allocated by the call\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @note\n To restore the device state at a later time, use #ic4_grabber_device_open_from_state.\\n\n In addition to serializing the device's properties (like #ic4_propmap_serialize_to_memory() would), this function also saves the\n currently opened video capture device so that it can be re-opened at a later time with all settings restored.\n\n @see ic4_grabber_load_device_state\n @see ic4_grabber_save_device_state_to_file"]
    pub fn ic4_grabber_device_save_state(
        pGrabber: *mut IC4_GRABBER,
        alloc: ic4_device_state_allocator,
        ppData: *mut *mut ::std::os::raw::c_void,
        data_size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Saves the currently opened video capture device and all its settings into a file.\n\n @param[in]\tpGrabber\tA grabber object with an opened device\n @param[in]\tfile_path\tPath to a file that the device state is written to.\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @note\n To restore the device state at a later time, use #ic4_grabber_device_open_from_state_file().\\n\n In addition to serializing the device's properties (like #ic4_propmap_serialize_to_file() would), this function also saves the\n currently opened video capture device so that it can be re-opened at a later time with all settings restored.\n\n @see ic4_grabber_device_open_from_state_file\n @see ic4_grabber_device_save_state"]
    pub fn ic4_grabber_device_save_state_to_file(
        pGrabber: *mut IC4_GRABBER,
        file_path: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn ic4_grabber_device_save_state_to_fileW(
        pGrabber: *mut IC4_GRABBER,
        file_path: *const u16,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Restores the opened device and its settings from a memory buffer containing data that was previously written by #ic4_grabber_device_save_state.\n\n @param[in]\tpGrabber\tA grabber object without an opened device\n @param[in]\tdata\t\tPointer to a memory buffer containing data that was written by #ic4_grabber_device_save_state\n @param[in]\tdata_size\tSize of the memory buffer pointed to by @c pData\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @note\n If the memory buffer contains settings for properties that could not be written, the function fails and the error value is set to #IC4_ERROR_INCOMPLETE.\n\n @see ic4_grabber_device_save_state"]
    pub fn ic4_grabber_device_open_from_state(
        pGrabber: *mut IC4_GRABBER,
        data: *const ::std::os::raw::c_void,
        data_size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Restores the opened device and its settings from a file that was previously written by #ic4_grabber_device_save_state_to_file().\n\n @param[in]\tpGrabber\tA grabber object without an opened device\n @param[in]\tfile_path\tPath to a file containing device state information\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @note\n If the file contains settings for properties that could not be written, the function fails and the error value is set to #IC4_ERROR_INCOMPLETE.\n\n @see ic4_grabber_device_save_state_to_file\n @see ic4_grabber_device_open_from_state"]
    pub fn ic4_grabber_device_open_from_state_file(
        pGrabber: *mut IC4_GRABBER,
        file_path: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn ic4_grabber_device_open_from_state_fileW(
        pGrabber: *mut IC4_GRABBER,
        file_path: *const u16,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IC4_DBG_BUFFER_STATS {
    pub num_announced: u64,
    pub num_queued: u64,
    pub num_await_delivery: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IC4_DBG_BUFFER_STATS"][::std::mem::size_of::<IC4_DBG_BUFFER_STATS>() - 24usize];
    ["Alignment of IC4_DBG_BUFFER_STATS"][::std::mem::align_of::<IC4_DBG_BUFFER_STATS>() - 8usize];
    ["Offset of field: IC4_DBG_BUFFER_STATS::num_announced"]
        [::std::mem::offset_of!(IC4_DBG_BUFFER_STATS, num_announced) - 0usize];
    ["Offset of field: IC4_DBG_BUFFER_STATS::num_queued"]
        [::std::mem::offset_of!(IC4_DBG_BUFFER_STATS, num_queued) - 8usize];
    ["Offset of field: IC4_DBG_BUFFER_STATS::num_await_delivery"]
        [::std::mem::offset_of!(IC4_DBG_BUFFER_STATS, num_await_delivery) - 16usize];
};
extern "C" {
    pub fn ic4_dbg_grabber_device_buffer_stats(
        pGrabber: *mut IC4_GRABBER,
        stats: *mut IC4_DBG_BUFFER_STATS,
    ) -> bool;
}
extern "C" {
    pub fn ic4_dbg_grabber_transform_buffer_stats(
        pGrabber: *mut IC4_GRABBER,
        stats: *mut IC4_DBG_BUFFER_STATS,
    ) -> bool;
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " @brief Defines the possible library log levels"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IC4_LOG_LEVEL {
    #[doc = "< Disable logging"]
    IC4_LOG_OFF = 0,
    #[doc = "< Log only errors"]
    IC4_LOG_ERROR = 1,
    #[doc = "< Log warnings and above"]
    IC4_LOG_WARN = 2,
    #[doc = "< Log info and above"]
    IC4_LOG_INFO = 3,
    #[doc = "< Log debug and above"]
    IC4_LOG_DEBUG = 4,
    #[doc = "< Log trace and above"]
    IC4_LOG_TRACE = 5,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " @brief Defines the possible log targets"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IC4_LOG_TARGET_FLAGS {
    #[doc = "< Disable logging"]
    IC4_LOGTARGET_DISABLE = 0,
    #[doc = "< Log to stdout"]
    IC4_LOGTARGET_STDOUT = 1,
    #[doc = "< Log to stderr"]
    IC4_LOGTARGET_STDERR = 2,
    #[doc = "< Log to a file specified by @ref IC4_INIT_CONFIG::log_file"]
    IC4_LOGTARGET_FILE = 4,
    #[doc = "< Log using @c OutputDebugString (Windows only)"]
    IC4_LOGTARGET_WINDEBUG = 8,
}
#[doc = " @brief The library initialization config structure\n\n Passed to @ref ic4_init_library when initializing the IC Imaging Control 4 C Library."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IC4_INIT_CONFIG {
    #[doc = " @brief Specifies the library API log level.\n\n This log level controls whether to log errors for failed library API function calls."]
    pub api_log_level: IC4_LOG_LEVEL,
    #[doc = " @brief Specifies the internal library log level.\n\n This log level controls internal library logging."]
    pub internal_log_level: IC4_LOG_LEVEL,
    #[doc = " @brief Selects the targets for logging.\n\n This is a bitwise combination of @ref IC4_LOG_TARGET_FLAGS values."]
    pub log_targets: IC4_LOG_TARGET_FLAGS,
    #[doc = " @brief Specifies the log file to use if @a log_targets has @ref IC4_LOGTARGET_FILE set."]
    pub log_file: *const ::std::os::raw::c_char,
    #[doc = " @brief Reserved. Must be 0."]
    pub reserved0: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IC4_INIT_CONFIG"][::std::mem::size_of::<IC4_INIT_CONFIG>() - 32usize];
    ["Alignment of IC4_INIT_CONFIG"][::std::mem::align_of::<IC4_INIT_CONFIG>() - 8usize];
    ["Offset of field: IC4_INIT_CONFIG::api_log_level"]
        [::std::mem::offset_of!(IC4_INIT_CONFIG, api_log_level) - 0usize];
    ["Offset of field: IC4_INIT_CONFIG::internal_log_level"]
        [::std::mem::offset_of!(IC4_INIT_CONFIG, internal_log_level) - 4usize];
    ["Offset of field: IC4_INIT_CONFIG::log_targets"]
        [::std::mem::offset_of!(IC4_INIT_CONFIG, log_targets) - 8usize];
    ["Offset of field: IC4_INIT_CONFIG::log_file"]
        [::std::mem::offset_of!(IC4_INIT_CONFIG, log_file) - 16usize];
    ["Offset of field: IC4_INIT_CONFIG::reserved0"]
        [::std::mem::offset_of!(IC4_INIT_CONFIG, reserved0) - 24usize];
};
extern "C" {
    #[doc = " @brief Initializes the IC Imaging Control 4 C Library\n\n ic4_init_library must be called before any other library function.\n\n @param init_config A structure configuring library settings, e.g. the log level.\n\n @return @c true on success, otherwise @c false."]
    pub fn ic4_init_library(init_config: *const IC4_INIT_CONFIG) -> bool;
}
extern "C" {
    #[doc = " @brief Un-initializes the library.\n\n Every successful call to @c ic4_init_library should be balanced by a matching call to @a ic4_exit_library before unloading the library DLL."]
    pub fn ic4_exit_library();
}
extern "C" {
    pub fn ic4_dbg_count_objects(type_name: *const ::std::os::raw::c_char) -> usize;
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " Identifies the type of a sink"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IC4_SINK_TYPE {
    #[doc = "< Queue sink"]
    IC4_SINK_TYPE_QUEUESINK = 4,
    #[doc = "< Snap sink"]
    IC4_SINK_TYPE_SNAPSINK = 5,
    #[doc = "< Not a sink type"]
    IC4_SINK_TYPE_INVALID = -1,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " Defines the possible sink modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IC4_SINK_MODE {
    #[doc = " The sink is operational."]
    IC4_SINK_MODE_RUN = 0,
    #[doc = " The sink is paused, immediately returning all image buffers it receives to the device to the device driver"]
    IC4_SINK_MODE_PAUSE = 1,
    #[doc = " Invalid sink mode, used to indicate an error"]
    IC4_SINK_MODE_INVALID = -1,
}
extern "C" {
    #[doc = " @brief Increases the sink's internal reference count by one.\n\n @param[in] pSink A pointer to a sink\n\n @return The pointer passed via \\a pSink\n\n @remarks If \\a pSink is \\c NULL, the function returns \\c NULL. An error value is not set.\n\n @see ic4_sink_unref"]
    pub fn ic4_sink_ref(pSink: *mut IC4_SINK) -> *mut IC4_SINK;
}
extern "C" {
    #[doc = " @brief Decreases the sink's internal reference count by one.\n\n If the reference count reaches zero, the object is destroyed.\n\n @param[in] pSink A pointer to a sink\n\n @remarks\n If \\a pSink is \\c NULL, the function does nothing. An error value is not set.\n\n @see ic4_sink_ref"]
    pub fn ic4_sink_unref(pSink: *mut IC4_SINK);
}
extern "C" {
    #[doc = " @brief Sets the sink mode for a sink.\n\n @param[in] pSink\tA sink\n @param[in] mode\tThe new sink mode\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information."]
    pub fn ic4_sink_set_mode(pSink: *mut IC4_SINK, mode: IC4_SINK_MODE) -> bool;
}
extern "C" {
    #[doc = " @brief Gets the current sink mode of a sink\n\n @param[in] pSink\tA sink\n\n @return\tA #IC4_SINK_MODE value describing the current sink mode.\\n\n\t\t\tIf an error occurred, the return value is \\c IC4_SINK_MODE_INVALID.\n\t\t\tUse ic4_get_last_error() to query error information.\n"]
    pub fn ic4_sink_get_mode(pSink: *mut IC4_SINK) -> IC4_SINK_MODE;
}
extern "C" {
    #[doc = " Checks whether a sink is currently attached to a @ref grabber.\n\n @param[in] pSink\n\n @return \\c true, if the sink is attached, otherwise \\c false."]
    pub fn ic4_sink_is_attached(pSink: *mut IC4_SINK) -> bool;
}
extern "C" {
    #[doc = " Returns the actual type of the sink\n\n @param[in] pSink A sink\n\n @return The type of the sink, or \\c IC4_SINK_TYPE_INVALID in case of an error.\\n\n\t\t\tUse ic4_get_last_error() to query error information."]
    pub fn ic4_sink_get_type(pSink: *mut IC4_SINK) -> IC4_SINK_TYPE;
}
#[doc = " Contains function pointers used to specify the behavior of a queue sink."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IC4_QUEUESINK_CALLBACKS {
    #[doc = " @brief Notifies the user that the sink will not call any additional callback functions.\n\n @anchor queuesink_release\n\n Any resources attached to the \\c context parameter can be released.\n\n @param[in] context   The \\c context parameter that was passed to #ic4_queuesink_create() when the sink was created\n\n @note\n The \\c release callback function is executed on the thread that destroys the sink using the final call to #ic4_sink_unref()."]
    pub release: ::std::option::Option<unsafe extern "C" fn(context: *mut ::std::os::raw::c_void)>,
    #[doc = " @brief Called when the data stream to the sink is created\n\n @anchor queuesink_sink_connected\n\n @param[in] sink                  The sink object\n @param[in] context               The \\c context parameter that was passed to #ic4_queuesink_create() when the sink was created\n @param[in] image_type            The negotiated image type that the sink will receive\n @param[in] min_buffers_required  The minimum number of buffers required by the device to start a stream\n\n @return  \\c true, if the data stream should be created.\n          If \\c false is returned the call to #ic4_grabber_stream_setup() will fail.\n\n @note\n @a min_buffers_required buffers have to be allocated and queued in order for the sink to begin operating.\n If the function does call @ref ic4_queuesink_alloc_and_queue_buffers(), the required number of buffers\n will be created automatically after the function returns.\n If the function does allocate buffers, but the number is lower than required, @ref ic4_grabber_stream_setup() will fail.\n\n @note\n The \\a queuesink_sink_connected function is executed on the thread that calls @ref ic4_grabber_stream_setup()."]
    pub sink_connected: ::std::option::Option<
        unsafe extern "C" fn(
            sink: *mut IC4_SINK,
            context: *mut ::std::os::raw::c_void,
            image_type: *const IC4_IMAGE_TYPE,
            min_buffers_required: usize,
        ) -> bool,
    >,
    #[doc = " Called when the data stream to the sink is stopped\n\n @anchor queuesink_sink_disconnected\n\n @param[in] sink          The sink object\n @param[in] context       The \\c context parameter that was passed to #ic4_queuesink_create() when the sink was created\n\n @note\n The \\a sink_disconnected function is executed on the thread that calls @ref ic4_grabber_stream_stop().\n\n @warning\n When the data stream to ths sink is stopped, the @ref ic4_grabber_stream_stop() call wait until this function returns.\n This can quickly lead to a deadlock, if code in the \\a sink_disconnected callback performs an operation that unconditionally requires\n activity on the thread that called @ref ic4_grabber_stream_stop()."]
    pub sink_disconnected: ::std::option::Option<
        unsafe extern "C" fn(sink: *mut IC4_SINK, context: *mut ::std::os::raw::c_void),
    >,
    #[doc = " Called when new images were added to the sink's queue of filled buffers\n\n This callback usually calls @ref ic4_queuesink_pop_output_buffer() to access the image buffers.\n\n @anchor queuesink_frames_queued\n\n @param[in] sink          The sink object\n @param[in] context       The \\c context parameter that was passed to #ic4_queuesink_create() when the sink was created\n\n @note\n If this callback function performs a lengthy operation, it is recommended to regularly check #ic4_queuesink_is_cancel_requested()\n to determine whether the data stream is being stopped.\n\n @note\n The \\a frames_queued function is executed on a dedicated thread managed by the sink.\n\n @warning\n When the data stream to ths sink is stopped, the #ic4_grabber_stream_stop() call wait until this function returns.\n This can quickly lead to a deadlock, if code in the \\c frames_queued callback performs an operation that unconditionally requires\n activity on the thread that called \\c ic4_grabber_stream_stop."]
    pub frames_queued: ::std::option::Option<
        unsafe extern "C" fn(sink: *mut IC4_SINK, context: *mut ::std::os::raw::c_void),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IC4_QUEUESINK_CALLBACKS"][::std::mem::size_of::<IC4_QUEUESINK_CALLBACKS>() - 32usize];
    ["Alignment of IC4_QUEUESINK_CALLBACKS"]
        [::std::mem::align_of::<IC4_QUEUESINK_CALLBACKS>() - 8usize];
    ["Offset of field: IC4_QUEUESINK_CALLBACKS::release"]
        [::std::mem::offset_of!(IC4_QUEUESINK_CALLBACKS, release) - 0usize];
    ["Offset of field: IC4_QUEUESINK_CALLBACKS::sink_connected"]
        [::std::mem::offset_of!(IC4_QUEUESINK_CALLBACKS, sink_connected) - 8usize];
    ["Offset of field: IC4_QUEUESINK_CALLBACKS::sink_disconnected"]
        [::std::mem::offset_of!(IC4_QUEUESINK_CALLBACKS, sink_disconnected) - 16usize];
    ["Offset of field: IC4_QUEUESINK_CALLBACKS::frames_queued"]
        [::std::mem::offset_of!(IC4_QUEUESINK_CALLBACKS, frames_queued) - 24usize];
};
#[doc = " @struct IC4_QUEUESINK_CONFIG\n\n @brief Configures the behavior of a queue sink.\n\n A pointer to a \\c IC4_QUEUESINK_CONFIG is passed to @ref ic4_queuesink_create()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IC4_QUEUESINK_CONFIG {
    #[doc = " @brief A structure containing function pointers to customize the sink's behavior.\n\n Programs usually at least register a callback for @ref IC4_QUEUESINK_CALLBACKS::frames_queued to be able\n to process new images immediately."]
    pub callbacks: IC4_QUEUESINK_CALLBACKS,
    #[doc = " @brief A user-defined value that is passed to the callbacks\n\n If \\c callback_context points to a memory location, and callback functions access that memory,\n the program has to make sure that the memory is valid until the @ref IC4_QUEUESINK_CALLBACKS::release callback is executed."]
    pub callback_context: *mut ::std::os::raw::c_void,
    #[doc = " @brief An array of possible pixel formats that the sink can receive."]
    pub pixel_formats: *const IC4_PIXEL_FORMAT,
    #[doc = " @brief Length of the @ref pixel_formats array.\n\n If this value is \\c 0, the sink will accept any pixel format."]
    pub num_pixel_formats: usize,
    #[doc = " @brief A structure containing function pointers to customize the sink's allocator.\n\n This parameter is optional, set all callback functions to \\c NULL to use the default allocator.\n\n If @ref IC4_ALLOCATOR_CALLBACKS::allocate_buffer is set, @ref IC4_ALLOCATOR_CALLBACKS::free_buffer must be set as well."]
    pub allocator: IC4_ALLOCATOR_CALLBACKS,
    #[doc = " @brief A user-defined value that is passed to the allocator callbacks\n\n If \\c callback_context points to a memory location, and callback functions access that memory,\n the program has to make sure that the memory is valid until the @ref IC4_ALLOCATOR_CALLBACKS::release callback is executed."]
    pub allocator_context: *mut ::std::os::raw::c_void,
    #[doc = " @brief Defines the maximum number of buffers that are stored in the sink's output queue.\n\n If set to @c 0, the number of buffers is unlimited.\n If a new frame arrives at the sink, and the output queue size would exceed @a max_output_buffers,\n the oldest image is discarded and its buffer is added to the free queue."]
    pub max_output_buffers: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IC4_QUEUESINK_CONFIG"][::std::mem::size_of::<IC4_QUEUESINK_CONFIG>() - 96usize];
    ["Alignment of IC4_QUEUESINK_CONFIG"][::std::mem::align_of::<IC4_QUEUESINK_CONFIG>() - 8usize];
    ["Offset of field: IC4_QUEUESINK_CONFIG::callbacks"]
        [::std::mem::offset_of!(IC4_QUEUESINK_CONFIG, callbacks) - 0usize];
    ["Offset of field: IC4_QUEUESINK_CONFIG::callback_context"]
        [::std::mem::offset_of!(IC4_QUEUESINK_CONFIG, callback_context) - 32usize];
    ["Offset of field: IC4_QUEUESINK_CONFIG::pixel_formats"]
        [::std::mem::offset_of!(IC4_QUEUESINK_CONFIG, pixel_formats) - 40usize];
    ["Offset of field: IC4_QUEUESINK_CONFIG::num_pixel_formats"]
        [::std::mem::offset_of!(IC4_QUEUESINK_CONFIG, num_pixel_formats) - 48usize];
    ["Offset of field: IC4_QUEUESINK_CONFIG::allocator"]
        [::std::mem::offset_of!(IC4_QUEUESINK_CONFIG, allocator) - 56usize];
    ["Offset of field: IC4_QUEUESINK_CONFIG::allocator_context"]
        [::std::mem::offset_of!(IC4_QUEUESINK_CONFIG, allocator_context) - 80usize];
    ["Offset of field: IC4_QUEUESINK_CONFIG::max_output_buffers"]
        [::std::mem::offset_of!(IC4_QUEUESINK_CONFIG, max_output_buffers) - 88usize];
};
extern "C" {
    #[doc = " @brief Creates a new @ref queuesink.\n\n @param[in] ppSink            Pointer to a sink handle to receive the new queue sink.\n @param[in] config            Pointer to a structure containing the sink configuration\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n The image type of the images the sink receives is determined when the data stream to the sink is created\n in a call to #ic4_grabber_stream_setup() using the following steps:\n  - If @ref IC4_QUEUESINK_CONFIG::num_pixel_formats is \\c 0, the device format is selected.\n  - If the device's output format matches one of the pixel formats passed in @ref IC4_QUEUESINK_CONFIG::pixel_formats, the first match is selected.\n  - If there is no direct match, but a conversion between the device's output format format and one of the passed pixel formats exists,\n      the first format with a conversion is selected.\n  - If no conversion between the device's output format and any of the values in @ref IC4_QUEUESINK_CONFIG::pixel_formats exists, the stream setup fails."]
    pub fn ic4_queuesink_create(
        ppSink: *mut *mut IC4_SINK,
        config: *const IC4_QUEUESINK_CONFIG,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Queries the image type of the images the sink is configured to receive.\n\n @param[in] pSink         A queue sink\n @param[out] image_type   A structure receiving the image type information\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @pre This operation is only valid while there is a data stream from a device to the sink."]
    pub fn ic4_queuesink_get_output_image_type(
        pSink: *const IC4_SINK,
        image_type: *mut IC4_IMAGE_TYPE,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Allocates a number of buffers matching the sink's image type and puts them into the free queue.\n\n @param[in] pSink         A queue sink\n @param[in] num_buffers   Number of buffers to allocate\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @pre This operation is only valid while the sink's image type is known. This is the case\\n\n          - inside the @ref IC4_QUEUESINK_CALLBACKS.sink_connected callback function\n          - when the sink was successfully connected to a data stream"]
    pub fn ic4_queuesink_alloc_and_queue_buffers(pSink: *mut IC4_SINK, num_buffers: usize) -> bool;
}
extern "C" {
    #[doc = " @brief Retrieves a buffer that was filled with image data from the sink's output queue.\n\n @param[in] pSink         A queue sink\n @param[out] ppImageBuffer      A pointer to a frame handle to receive the newly-filled image\\n\n\n @return \\c true if a buffer was successfully dequeued, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @pre\n This operation is only valid while the sink is connected to a device in a data stream.\n\n @note\n The buffers are retrieved in order they were received from the video capture device; the oldest image is\n returned first.\n\n @note\n After a successfull call, the handle pointed to by \\c ppImageBuffer owns the frame object.\\n\n A call to #ic4_imagebuffer_unref() is required to put the image buffer into the sink's free queue for later reuse.\\n"]
    pub fn ic4_queuesink_pop_output_buffer(
        pSink: *mut IC4_SINK,
        ppImageBuffer: *mut *mut IC4_IMAGE_BUFFER,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Checks whether the data stream this sink is connected to is in the process of being stopped.\n\n This function can be used to cancel a long-running operation in the @ref IC4_QUEUESINK_CALLBACKS.frames_queued callback.\n\n @param[in] pSink             A queue sink\n @param[out] cancel_requested Pointer to a flag that receives the cancel request\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n"]
    pub fn ic4_queuesink_is_cancel_requested(
        pSink: *const IC4_SINK,
        cancel_requested: *mut bool,
    ) -> bool;
}
#[doc = " @brief Contains information about the current queue lengths inside the queue sink."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IC4_QUEUESINK_QUEUE_SIZES {
    #[doc = "< Number of image buffers in the free queue"]
    pub free_queue_length: usize,
    #[doc = "< Number of filled image buffers in the output queue"]
    pub output_queue_length: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IC4_QUEUESINK_QUEUE_SIZES"]
        [::std::mem::size_of::<IC4_QUEUESINK_QUEUE_SIZES>() - 16usize];
    ["Alignment of IC4_QUEUESINK_QUEUE_SIZES"]
        [::std::mem::align_of::<IC4_QUEUESINK_QUEUE_SIZES>() - 8usize];
    ["Offset of field: IC4_QUEUESINK_QUEUE_SIZES::free_queue_length"]
        [::std::mem::offset_of!(IC4_QUEUESINK_QUEUE_SIZES, free_queue_length) - 0usize];
    ["Offset of field: IC4_QUEUESINK_QUEUE_SIZES::output_queue_length"]
        [::std::mem::offset_of!(IC4_QUEUESINK_QUEUE_SIZES, output_queue_length) - 8usize];
};
extern "C" {
    #[doc = " @brief Query information about the number of image buffers in the queue sink's queues.\n\n @param[in] pSink     A queue sink\n @param[out] sizes    A pointer to a structure to receive the queue lengths\n\n @pre\n This operation is only valid while there is a data stream from a device to the sink.\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information."]
    pub fn ic4_queuesink_get_queue_sizes(
        pSink: *const IC4_SINK,
        sizes: *mut IC4_QUEUESINK_QUEUE_SIZES,
    ) -> bool;
}
#[doc = " @brief Contains image file storage options for bitmap files."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IC4_IMAGEBUFFER_SAVE_OPTIONS_BMP {
    #[doc = " @brief If set, and the image buffer's pixel format is a bayer format, interpret the pixel data as monochrome\n and store the raw data as a monochrome image."]
    pub store_bayer_raw_data_as_monochrome: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IC4_IMAGEBUFFER_SAVE_OPTIONS_BMP"]
        [::std::mem::size_of::<IC4_IMAGEBUFFER_SAVE_OPTIONS_BMP>() - 4usize];
    ["Alignment of IC4_IMAGEBUFFER_SAVE_OPTIONS_BMP"]
        [::std::mem::align_of::<IC4_IMAGEBUFFER_SAVE_OPTIONS_BMP>() - 4usize];
    ["Offset of field: IC4_IMAGEBUFFER_SAVE_OPTIONS_BMP::store_bayer_raw_data_as_monochrome"][::std::mem::offset_of!(
        IC4_IMAGEBUFFER_SAVE_OPTIONS_BMP,
        store_bayer_raw_data_as_monochrome
    )
        - 0usize];
};
#[repr(i32)]
#[non_exhaustive]
#[doc = " Defines the possible PNG file compression levels.\n\n Higher compression levels can generate smaller files, but the compression can take more time."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IC4_PNG_COMPRESSION_LEVEL {
    #[doc = "< Automatically select a compression level"]
    IC4_PNG_COMPRESSION_AUTO = 0,
    #[doc = "< Low compression"]
    IC4_PNG_COMPRESSION_LOW = 1,
    #[doc = "< Medium compression"]
    IC4_PNG_COMPRESSION_MEDIUM = 2,
    #[doc = "< High compression"]
    IC4_PNG_COMPRESSION_HIGH = 3,
    #[doc = "< Highest compression"]
    IC4_PNG_COMPRESSION_HIGHEST = 4,
}
#[doc = " @brief Contains image file storage options for PNG files."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IC4_IMAGEBUFFER_SAVE_OPTIONS_PNG {
    #[doc = " @brief If set, and the image buffer's pixel format is a bayer format, interpret the pixel data as monochrome\n and store the raw data as a monochrome image."]
    pub store_bayer_raw_data_as_monochrome: ::std::os::raw::c_int,
    #[doc = " Specifies the PNG compression level"]
    pub compression_level: IC4_PNG_COMPRESSION_LEVEL,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IC4_IMAGEBUFFER_SAVE_OPTIONS_PNG"]
        [::std::mem::size_of::<IC4_IMAGEBUFFER_SAVE_OPTIONS_PNG>() - 8usize];
    ["Alignment of IC4_IMAGEBUFFER_SAVE_OPTIONS_PNG"]
        [::std::mem::align_of::<IC4_IMAGEBUFFER_SAVE_OPTIONS_PNG>() - 4usize];
    ["Offset of field: IC4_IMAGEBUFFER_SAVE_OPTIONS_PNG::store_bayer_raw_data_as_monochrome"][::std::mem::offset_of!(
        IC4_IMAGEBUFFER_SAVE_OPTIONS_PNG,
        store_bayer_raw_data_as_monochrome
    )
        - 0usize];
    ["Offset of field: IC4_IMAGEBUFFER_SAVE_OPTIONS_PNG::compression_level"]
        [::std::mem::offset_of!(IC4_IMAGEBUFFER_SAVE_OPTIONS_PNG, compression_level) - 4usize];
};
#[doc = " @brief Contains image file storage options for Jpeg files."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IC4_IMAGEBUFFER_SAVE_OPTIONS_JPEG {
    #[doc = " @brief Specifies the Jpeg image quality in percent.\n\n High quality images will take more disk space, low quality images are smaller."]
    pub quality_pct: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IC4_IMAGEBUFFER_SAVE_OPTIONS_JPEG"]
        [::std::mem::size_of::<IC4_IMAGEBUFFER_SAVE_OPTIONS_JPEG>() - 4usize];
    ["Alignment of IC4_IMAGEBUFFER_SAVE_OPTIONS_JPEG"]
        [::std::mem::align_of::<IC4_IMAGEBUFFER_SAVE_OPTIONS_JPEG>() - 4usize];
    ["Offset of field: IC4_IMAGEBUFFER_SAVE_OPTIONS_JPEG::quality_pct"]
        [::std::mem::offset_of!(IC4_IMAGEBUFFER_SAVE_OPTIONS_JPEG, quality_pct) - 0usize];
};
#[doc = " @brief Contains image file storage options for TIFF files."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IC4_IMAGEBUFFER_SAVE_OPTIONS_TIFF {
    #[doc = " @brief If set, and the image buffer's pixel format is a bayer format, interpret the pixel data as monochrome\n and store the raw data as a monochrome image."]
    pub store_bayer_raw_data_as_monochrome: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IC4_IMAGEBUFFER_SAVE_OPTIONS_TIFF"]
        [::std::mem::size_of::<IC4_IMAGEBUFFER_SAVE_OPTIONS_TIFF>() - 4usize];
    ["Alignment of IC4_IMAGEBUFFER_SAVE_OPTIONS_TIFF"]
        [::std::mem::align_of::<IC4_IMAGEBUFFER_SAVE_OPTIONS_TIFF>() - 4usize];
    ["Offset of field: IC4_IMAGEBUFFER_SAVE_OPTIONS_TIFF::store_bayer_raw_data_as_monochrome"][::std::mem::offset_of!(
        IC4_IMAGEBUFFER_SAVE_OPTIONS_TIFF,
        store_bayer_raw_data_as_monochrome
    )
        - 0usize];
};
extern "C" {
    #[doc = " @brief Saves an image buffer as a Bitmap file.\n\n @param[in] pImageBuffer\tAn image buffer\n @param[in] file_path\tPath of the image file\n @param[in] options\tOptions structure configuring the save operation\n\n @note\n Depending on the pixel format of the image buffer, a transformation is applied before saving the image.\n\t- Monochrome pixel formats are converted to Mono8 and stored as a 8-bit monochrome bitmap file\n\t- Bayer, RGB and YUV pixel formats are converted to BGR8 and stored as a 24-bit color bitmap file\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information."]
    pub fn ic4_imagebuffer_save_as_bmp(
        pImageBuffer: *mut IC4_IMAGE_BUFFER,
        file_path: *const ::std::os::raw::c_char,
        options: *const IC4_IMAGEBUFFER_SAVE_OPTIONS_BMP,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Saves an image buffer as a Jpeg file.\n\n @param[in] pImageBuffer\tAn image buffer\n @param[in] file_path\tPath of the image file\n @param[in] options\tOptions structure configuring the save operation\n\n @note\n Depending on the pixel format of the image buffer, a transformation is applied before saving the image.\n\t- Monochrome pixel formats are converted to Mono8 and stored as a monochrome jpeg file\n\t- Bayer, RGB and YUV pixel formats are converted to BGR8 stored as a color jpeg file\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information."]
    pub fn ic4_imagebuffer_save_as_jpeg(
        pImageBuffer: *mut IC4_IMAGE_BUFFER,
        file_path: *const ::std::os::raw::c_char,
        options: *const IC4_IMAGEBUFFER_SAVE_OPTIONS_JPEG,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Saves an image buffer as a Tiff file.\n\n @param[in] pImageBuffer\tAn image buffer\n @param[in] file_path\tPath of the image file\n @param[in] options\tOptions structure configuring the save operation\n\n @note\n Depending on the pixel format of the image buffer, a transformation is applied before saving the image.\n\t- Monochrome pixel formats with a bit depth higher than 8bpp are converted to Mono16 and stored as a monochrome Tiff file with 16 bits per channel\n\t- Mono8 image buffers are stored as a monochrome Tiff file with 8 bits per channel\n\t- Bayer format with a bit depth higher than 8bpp are converted to BGRa16 and stored as a 4-channel Tiff with 16 bits per channel\n\t- 8-bit Bayer, RGB and YUV pixel formats are converted to BGR8 stored as a 3-channel Tiff file with 8 bits per channel\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information."]
    pub fn ic4_imagebuffer_save_as_tiff(
        pImageBuffer: *mut IC4_IMAGE_BUFFER,
        file_path: *const ::std::os::raw::c_char,
        options: *const IC4_IMAGEBUFFER_SAVE_OPTIONS_TIFF,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Saves an image buffer as a PNG file.\n\n @param[in] pImageBuffer\tAn image buffer\n @param[in] file_path\tPath of the image file\n @param[in] options\tOptions structure configuring the save operation\n\n @note\n Depending on the pixel format of the image buffer, a transformation is applied before saving the image.\n\t- Monochrome pixel formats with a bit depth higher than 8bpp are converted to Mono16 and stored as a monochrome PNG file with 16 bits per channel\n\t- Mono8 image buffers are stored as a monochrome PNG file with 8 bits per channel\n\t- Bayer format with a bit depth higher than 8bpp are converted to BGRa16 and stored as a 4-channel PNG with 16 bits per channel\n\t- 8-bit Bayer, RGB and YUV pixel formats are converted to BGR8 stored as a 3-channel PNG file with 8 bits per channel\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information."]
    pub fn ic4_imagebuffer_save_as_png(
        pImageBuffer: *mut IC4_IMAGE_BUFFER,
        file_path: *const ::std::os::raw::c_char,
        options: *const IC4_IMAGEBUFFER_SAVE_OPTIONS_PNG,
    ) -> bool;
}
extern "C" {
    pub fn ic4_imagebuffer_save_as_bmpW(
        pImageBuffer: *mut IC4_IMAGE_BUFFER,
        file_path: *const u16,
        options: *const IC4_IMAGEBUFFER_SAVE_OPTIONS_BMP,
    ) -> bool;
}
extern "C" {
    pub fn ic4_imagebuffer_save_as_jpegW(
        pImageBuffer: *mut IC4_IMAGE_BUFFER,
        file_path: *const u16,
        options: *const IC4_IMAGEBUFFER_SAVE_OPTIONS_JPEG,
    ) -> bool;
}
extern "C" {
    pub fn ic4_imagebuffer_save_as_tiffW(
        pImageBuffer: *mut IC4_IMAGE_BUFFER,
        file_path: *const u16,
        options: *const IC4_IMAGEBUFFER_SAVE_OPTIONS_TIFF,
    ) -> bool;
}
extern "C" {
    pub fn ic4_imagebuffer_save_as_pngW(
        pImageBuffer: *mut IC4_IMAGE_BUFFER,
        file_path: *const u16,
        options: *const IC4_IMAGEBUFFER_SAVE_OPTIONS_PNG,
    ) -> bool;
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " @brief The buffer allocation strategy defines how many buffers are pre-allocated, when additional buffers are created,\n and when excess buffers are reclaimed."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IC4_SNAPSINK_ALLOCATION_STRATEGY {
    #[doc = " @brief Use the default strategy\n\n This strategy pre-allocates an automatically selected number of buffers depending on the requirements of the data stream\n and the image size.\n\n The custom strategy parameters in @ref IC4_SNAPSINK_CONFIG setting are ignored."]
    IC4_SNAPSINK_ALLOCATION_STRATEGY_DEFAULT = 0,
    #[doc = " @brief Custom allocation strategy\n\n The @ref IC4_SNAPSINK_CONFIG::num_buffers_alloc_on_connect, @ref IC4_SNAPSINK_CONFIG::num_buffers_allocation_threshold\n @ref IC4_SNAPSINK_CONFIG::num_buffers_free_threshold and @ref IC4_SNAPSINK_CONFIG::num_buffers_max parameters determine\n the sink's allocation behavior."]
    IC4_SNAPSINK_ALLOCATION_STRATEGY_CUSTOM = 1,
}
#[doc = " @struct IC4_SNAPSINK_CONFIG\n\n @brief Configures the behavior of a snap sink.\n\n A pointer to a \\c IC4_SNAPSINK_CONFIG is passed to @ref ic4_snapsink_create()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IC4_SNAPSINK_CONFIG {
    #[doc = " @brief Specifies the sink's buffer allocation strategy.\n\n The buffer allocation strategy defines how many buffers are pre-allocated, when additional buffers are created,\n and when excess buffers are reclaimed."]
    pub strategy: IC4_SNAPSINK_ALLOCATION_STRATEGY,
    #[doc = " @brief Defines the number of buffers to auto-allocate when the stream is set up.\n\n This value is ignored unless @a strategy is set to @ref IC4_SNAPSINK_ALLOCATION_STRATEGY_CUSTOM."]
    pub num_buffers_alloc_on_connect: usize,
    #[doc = " @brief Defines the minimum number of required free buffers.\n\n If the number of free buffers falls below this, new buffers are allocated.\n\n This value is ignored unless @a strategy is set to @ref IC4_SNAPSINK_ALLOCATION_STRATEGY_CUSTOM."]
    pub num_buffers_allocation_threshold: usize,
    #[doc = " @brief Defines the maximum number of free buffers\n\n If the number of free buffers grows above this, buffers are freed.\n\n If set to @c 0, buffers are not freed automatically.\n\n This value is ignored unless @a strategy is set to @ref IC4_SNAPSINK_ALLOCATION_STRATEGY_CUSTOM.\n\n @note\n If @c num_buffers_free_threshold is not @c 0, it must be larger than @ref num_buffers_allocation_threshold @c + @c 2."]
    pub num_buffers_free_threshold: usize,
    #[doc = " @brief Defines the maximum total number of buffers this sink will allocate.\n\n This includes both free buffers managed by the sink and filled buffers owned by the program.\n\n If set to @c 0, there is no limit to the total number of buffers.\n\n This value is ignored unless @a strategy is set to @ref IC4_SNAPSINK_ALLOCATION_STRATEGY_CUSTOM."]
    pub num_buffers_max: usize,
    #[doc = " @brief An array of possible pixel formats that the sink can receive.\n\n The image types can be partially specified."]
    pub pixel_formats: *const IC4_PIXEL_FORMAT,
    #[doc = " @brief Length of the @ref pixel_formats array.\n\n If this value is \\c 0, the sink will accept any pixel format."]
    pub num_pixel_formats: usize,
    #[doc = " @brief A structure containing function pointers to customize the sink's allocator.\n\n This parameter is optional, set all callback functions to \\c to use the default allocator.\n\n If @ref IC4_ALLOCATOR_CALLBACKS::allocate_buffer is set, @ref IC4_ALLOCATOR_CALLBACKS::free_buffer must be set as well."]
    pub allocator: IC4_ALLOCATOR_CALLBACKS,
    #[doc = " @brief A user-defined value that is passed to the allocator callbacks\n\n If \\c callback_context points to a memory location, and callback functions access that memory,\n the program has to make sure that the memory is valid until the @ref IC4_ALLOCATOR_CALLBACKS::release callback is executed."]
    pub allocator_context: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IC4_SNAPSINK_CONFIG"][::std::mem::size_of::<IC4_SNAPSINK_CONFIG>() - 88usize];
    ["Alignment of IC4_SNAPSINK_CONFIG"][::std::mem::align_of::<IC4_SNAPSINK_CONFIG>() - 8usize];
    ["Offset of field: IC4_SNAPSINK_CONFIG::strategy"]
        [::std::mem::offset_of!(IC4_SNAPSINK_CONFIG, strategy) - 0usize];
    ["Offset of field: IC4_SNAPSINK_CONFIG::num_buffers_alloc_on_connect"]
        [::std::mem::offset_of!(IC4_SNAPSINK_CONFIG, num_buffers_alloc_on_connect) - 8usize];
    ["Offset of field: IC4_SNAPSINK_CONFIG::num_buffers_allocation_threshold"]
        [::std::mem::offset_of!(IC4_SNAPSINK_CONFIG, num_buffers_allocation_threshold) - 16usize];
    ["Offset of field: IC4_SNAPSINK_CONFIG::num_buffers_free_threshold"]
        [::std::mem::offset_of!(IC4_SNAPSINK_CONFIG, num_buffers_free_threshold) - 24usize];
    ["Offset of field: IC4_SNAPSINK_CONFIG::num_buffers_max"]
        [::std::mem::offset_of!(IC4_SNAPSINK_CONFIG, num_buffers_max) - 32usize];
    ["Offset of field: IC4_SNAPSINK_CONFIG::pixel_formats"]
        [::std::mem::offset_of!(IC4_SNAPSINK_CONFIG, pixel_formats) - 40usize];
    ["Offset of field: IC4_SNAPSINK_CONFIG::num_pixel_formats"]
        [::std::mem::offset_of!(IC4_SNAPSINK_CONFIG, num_pixel_formats) - 48usize];
    ["Offset of field: IC4_SNAPSINK_CONFIG::allocator"]
        [::std::mem::offset_of!(IC4_SNAPSINK_CONFIG, allocator) - 56usize];
    ["Offset of field: IC4_SNAPSINK_CONFIG::allocator_context"]
        [::std::mem::offset_of!(IC4_SNAPSINK_CONFIG, allocator_context) - 80usize];
};
extern "C" {
    #[doc = " @brief Creates a new @ref snapsink.\n\n @param[in] ppSink            Pointer to a sink handle to receive the new snap sink.\n @param[in] config            Pointer to a structure containing the sink configuration.\\n\n                              This parameter is optional; passing @c NULL will use the default configuration.\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n The image type of the images the sink receives is determined when the data stream to the sink is created\n in a call to #ic4_grabber_stream_setup() using the following steps:\n  - If @ref IC4_SNAPSINK_CONFIG::num_pixel_formats is \\c 0, the device format is selected.\n  - If the device's output format matches one of the pixel formats passed in @ref IC4_SNAPSINK_CONFIG::pixel_formats, the first match is selected.\n  - If there is no direct match, but a conversion between the device's output format format and one of the passed pixel formats exists,\n      the first format with a conversion is selected.\n  - If no conversion between the device's output format and any of the values in @ref IC4_SNAPSINK_CONFIG::pixel_formats exists, the stream setup fails."]
    pub fn ic4_snapsink_create(
        ppSink: *mut *mut IC4_SINK,
        config: *const IC4_SNAPSINK_CONFIG,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Queries the image type of the images the sink is configured to receive.\n\n @param[in] pSink         A queue sink\n @param[out] image_type   A structure receiving the image type information\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @pre This operation is only valid while there is a data stream from a device to the sink."]
    pub fn ic4_snapsink_get_output_image_type(
        pSink: *const IC4_SINK,
        image_type: *mut IC4_IMAGE_TYPE,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Grabs a single image out of the video stream received from the video capture device.\n\n This function waits until either the next buffer from the video capture device is received, or @c timeout_ms milliseconds have passed.\n If the timeout expires, the function fails and the error value is set to @ref IC4_ERROR_TIMEOUT.\n\n @param[in] pSink             A snap sink\n @param[out] ppImageBuffer    A pointer to a frame handle to receive the newly-filled image\n @param[in] timeout_ms        Time to wait for a new image to arrive\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information.\n\n @pre\n This operation is only valid while the sink is connected to a device in a data stream.\n\n @note\n After a successfull call, the handle pointed to by \\c ppImageBuffer owns the frame object.\\n\n A call to #ic4_imagebuffer_unref() is required to return the image buffer to the sink for reuse.\\n"]
    pub fn ic4_snapsink_snap_single(
        pSink: *const IC4_SINK,
        ppImageBuffer: *mut *mut IC4_IMAGE_BUFFER,
        timeout_ms: i64,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Grabs a sequence of images out of the video stream received from the video capture device.\n\n This function waits until @a count images have been grabbed, or @a timeout_ms milliseconds have passed.\n If the timeout expires, the function returns the number of images grabber and the error value is set to @ref IC4_ERROR_TIMEOUT.\n\n @param[in] pSink         A snap sink\n @param[out] pImageBufferList   A pointer to an array of frame handles to receive the newly-filled images\n @param[in] count         Number of images to grab\n @param[in] timeout_ms    Time to wait for all images to arrive\n\n @return  The number of images grabbed successfully.\\n\n          If an error occurred, the function returns @c 0. Use ic4_get_last_error() to query error information.\n\n @pre\n This operation is only valid while the sink is connected to a device in a data stream.\n\n @note\n After a successfull call, the handles pointed to by \\c pImageBufferList own the frame objects.\\n\n A call to #ic4_imagebuffer_unref() is required to return each image buffer to the sink for reuse.\\n"]
    pub fn ic4_snapsink_snap_sequence(
        pSink: *const IC4_SINK,
        pImageBufferList: *mut *mut IC4_IMAGE_BUFFER,
        count: usize,
        timeout_ms: i64,
    ) -> usize;
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " Defines the available video writer types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IC4_VIDEO_WRITER_TYPE {
    #[doc = "< Create MP4 files with H.264 encoding"]
    IC4_VIDEO_WRITER_MP4_H264 = 0,
    #[doc = "< Create MP4 files with H.265/HEVC encoding"]
    IC4_VIDEO_WRITER_MP4_H265 = 1,
}
#[doc = " @struct IC4_VIDEO_WRITER\n\n @brief Represents a video writer\n\n This type is opaque, programs only use pointers of type \\c IC4_VIDEO_WRITER*.\n\n Video writer objects are reference-counted.\n To increase the reference count, use #ic4_videowriter_ref().\n Call ic4_videowriter_unref() when a reference is no longer required."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IC4_VIDEO_WRITER {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @brief Creates a new video writer of the specified type.\n\n @param[in] type\t\t\t\tSelects the type of video writer to create\n @param[out] ppVideoWriter\tPointer to receive the handle of the new video writer\\n\n\t\t\t\t\t\t\t\tWhen the video writer is no longer required, release the object reference using #ic4_videowriter_unref().\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information."]
    pub fn ic4_videowriter_create(
        type_: IC4_VIDEO_WRITER_TYPE,
        ppVideoWriter: *mut *mut IC4_VIDEO_WRITER,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Increases the video writer's internal reference count by one.\n\n @param[in] pVideoWriter A pointer to a video writer\n\n @return The pointer passed via \\a pDisplay\n\n @remarks If \\a pVideoWriter is \\c NULL, the function returns \\c NULL. An error value is not set.\n\n @see ic4_videowriter_unref"]
    pub fn ic4_videowriter_ref(pVideoWriter: *mut IC4_VIDEO_WRITER) -> *mut IC4_VIDEO_WRITER;
}
extern "C" {
    #[doc = " @brief Decreases the video writer's internal reference count by one.\n\n If the reference count reaches zero, the object is destroyed.\n\n @param[in] pVideoWriter A pointer to a video writer\n\n @remarks If \\a pVideoWriter is \\c NULL, the function does nothing. An error value is not set.\n\n @see ic4_videowriter_ref"]
    pub fn ic4_videowriter_unref(pVideoWriter: *mut IC4_VIDEO_WRITER);
}
extern "C" {
    #[doc = " @brief Opens a new video file ready to write images into.\n\n @param[in] pVideoWriter\tA video writer\n @param[in] file_name\t\tName of the new video file\n @param[in] image_type\tImage type of the images that are going to be written\n @param[in] frame_rate\tPlayback frame rate of the video file\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information."]
    pub fn ic4_videowriter_begin_file(
        pVideoWriter: *mut IC4_VIDEO_WRITER,
        file_name: *const ::std::os::raw::c_char,
        image_type: *const IC4_IMAGE_TYPE,
        frame_rate: f64,
    ) -> bool;
}
extern "C" {
    pub fn ic4_videowriter_begin_fileW(
        pVideoWriter: *mut IC4_VIDEO_WRITER,
        file_name: *const u16,
        image_type: *const IC4_IMAGE_TYPE,
        frame_rate: f64,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Finishes writing a video file.\n\n @param[in] pVideoWriter\tA video writer that previously began writing a file\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information."]
    pub fn ic4_videowriter_finish_file(pVideoWriter: *mut IC4_VIDEO_WRITER) -> bool;
}
extern "C" {
    #[doc = " @brief Adds an image to the currently open video file.\n\n @param[in] pVideoWriter\tA video writer that previously began writing a file\n @param[in] buffer\t\tAn image buffer\n\n @note\n The image buffer's image type must be equal to the \\c image_type parameter passed to #ic4_videowriter_begin_file() when starting the file.\\n\n The video writer can retain a reference to the image buffer. This can delay the release and possible reuse of the image buffer.\n In this case, the buffer becomes shared, and is no longer safely writable (see @ref ic4_imagebuffer_is_writable).\\n\n Use @ref ic4_videowriter_add_frame_copy to always let the video writer immediately copy the data out of the image buffer.\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information."]
    pub fn ic4_videowriter_add_frame(
        pVideoWriter: *mut IC4_VIDEO_WRITER,
        buffer: *mut IC4_IMAGE_BUFFER,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Adds an image to the currently open video file, copying its contents in the process.\n\n @param[in] pVideoWriter\tA video writer that previously began writing a file\n @param[in] buffer\t\tAn image buffer\n\n @note\n The image buffer's image type must be equal to the \\c image_type parameter passed to #ic4_videowriter_begin_file() when starting the file.\\n\n The image buffer's contents will be copied, so that the buffer's reference count is not increased and it can be reused immedietely if\n the final reference is released.\\n\n Use @ref ic4_videowriter_add_frame to avoid the copy operation if it is not necessary.\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information."]
    pub fn ic4_videowriter_add_frame_copy(
        pVideoWriter: *mut IC4_VIDEO_WRITER,
        buffer: *const IC4_IMAGE_BUFFER,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Returns the property map for encoder configuration.\n\n @param[in] pVideoWriter\t\tA video writer\n @param[out] ppPropertyMap\tPointer to a handle that receives the property map.\\n\n\t\t\t\t\t\t\t\tWhen the property map is longer required, call #ic4_propmap_unref().\n\n @return \\c true on success, otherwise \\c false.\\n\n\t\t\tUse ic4_get_last_error() to query error information."]
    pub fn ic4_videowriter_get_property_map(
        pVideoWriter: *mut IC4_VIDEO_WRITER,
        ppPropertyMap: *mut *mut IC4_PROPERTY_MAP,
    ) -> bool;
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " @brief Contains retrievable version descriptions"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IC4_VERSION_INFO_FLAGS {
    #[doc = "< Give the most useful information"]
    IC4_VERSION_INFO_DEFAULT = 0,
    #[doc = "< Give as much information as possible"]
    IC4_VERSION_INFO_ALL = 1,
    #[doc = "< Information about IC4 core libraries"]
    IC4_VERSION_INFO_IC4 = 2,
    #[doc = "< Information about TIS GenTL providers"]
    IC4_VERSION_INFO_DRIVER = 4,
    #[doc = "< Information about IC4 plugins"]
    IC4_VERSION_INFO_PLUGINS = 8,
}
extern "C" {
    #[doc = " @brief Retrieve version information description string\n\n @param[out] str         Pointer to a character array to receive an error message.\n @param[in,out] size     Size of str buffer\n @param[in] flags        What version information to retrieve\n\n @return \\c true on success"]
    pub fn ic4_get_version_info(
        str_: *mut ::std::os::raw::c_char,
        size: *mut usize,
        flags: IC4_VERSION_INFO_FLAGS,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Shows a dialog that allows the user to select a video capture device. The device is opened in the passed @ref IC4_GRABBER object.\n\n @param[in] hParent\tA parent window for the dialog\n @param[in] pGrabber\tA grabber object in which the new device is to be opened\n\n @return @c true, if a device was selected and opened succesfully, otherwise @c false."]
    pub fn ic4_gui_grabber_select_device(
        hParent: IC4_WINDOW_HANDLE,
        pGrabber: *mut IC4_GRABBER,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Shows a dialog that allows the user to select a video capture device. A @ref IC4_DEVICE_INFO representing the selected device is returned\n in an output parameter.\n\n @param[in] hParent\tA parent window for the dialog\n @param[out] ppInfo\tA pointer to a handle to receive the device information object.\\n\n\t\t\t\t\t\tWhen the device information object is no longer required, release the object reference using #ic4_devinfo_unref().\n\n @return @c true, if a device was selected, otherwise @c false."]
    pub fn ic4_gui_select_device(
        hParent: IC4_WINDOW_HANDLE,
        ppInfo: *mut *mut IC4_DEVICE_INFO,
    ) -> bool;
}
#[repr(i32)]
#[non_exhaustive]
#[doc = " @brief Defines a set of flags to customize the behavior of the dialogs displayed by the@ref ic4_gui_grabber_show_device_properties()\n and @ref ic4_gui_show_property_map() functions."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum IC4_PROPERTY_DIALOG_FLAGS {
    IC4_PROPERTY_DIALOG_DEFAULT = 0,
    IC4_PROPERTY_DIALOG_ALLOW_STREAM_RESTART = 1,
    IC4_PROPERTY_DIALOG_RESTORE_STATE_ON_CANCEL = 2,
    IC4_PROPERTY_DIALOG_SHOW_TOP_CATEGORY = 4,
    IC4_PROPERTY_DIALOG_HIDE_FILTER = 8,
}
#[doc = " @brief A structure containing options customizing the appearance and behavior of the property dialog displayed by\n the @ref ic4_gui_grabber_show_device_properties() and @ref ic4_gui_show_property_map() functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IC4_PROPERTY_DIALOG_OPTIONS {
    #[doc = " @brief A bitwise combination of flags."]
    pub flags: IC4_PROPERTY_DIALOG_FLAGS,
    #[doc = " @brief The initially selected value in the visibility dropdown box"]
    pub initial_visibility: IC4_PROPERTY_VISIBILITY,
    #[doc = " @brief The initially configured filter text"]
    pub initial_filter: *const ::std::os::raw::c_char,
    #[doc = " @brief The category from the property map to show the properties for.\n\n If not set, the @c Root category is displayed."]
    pub category: *const ::std::os::raw::c_char,
    #[doc = " @brief A title for the dialog box"]
    pub title: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of IC4_PROPERTY_DIALOG_OPTIONS"]
        [::std::mem::size_of::<IC4_PROPERTY_DIALOG_OPTIONS>() - 32usize];
    ["Alignment of IC4_PROPERTY_DIALOG_OPTIONS"]
        [::std::mem::align_of::<IC4_PROPERTY_DIALOG_OPTIONS>() - 8usize];
    ["Offset of field: IC4_PROPERTY_DIALOG_OPTIONS::flags"]
        [::std::mem::offset_of!(IC4_PROPERTY_DIALOG_OPTIONS, flags) - 0usize];
    ["Offset of field: IC4_PROPERTY_DIALOG_OPTIONS::initial_visibility"]
        [::std::mem::offset_of!(IC4_PROPERTY_DIALOG_OPTIONS, initial_visibility) - 4usize];
    ["Offset of field: IC4_PROPERTY_DIALOG_OPTIONS::initial_filter"]
        [::std::mem::offset_of!(IC4_PROPERTY_DIALOG_OPTIONS, initial_filter) - 8usize];
    ["Offset of field: IC4_PROPERTY_DIALOG_OPTIONS::category"]
        [::std::mem::offset_of!(IC4_PROPERTY_DIALOG_OPTIONS, category) - 16usize];
    ["Offset of field: IC4_PROPERTY_DIALOG_OPTIONS::title"]
        [::std::mem::offset_of!(IC4_PROPERTY_DIALOG_OPTIONS, title) - 24usize];
};
extern "C" {
    #[doc = " @brief Shows a dialog box allowing the user to configure the properties of the video capture opened in the passed @ref IC4_GRABBER.\n\n @param[in] hParent\tA parent window for the dialog\n @param pGrabber\t\tA grabber object whose video capture device is to be configured\n @param[in] options\tAn options structure to customize the dialog's behavior\n\n @return @c true, if the user closed the dialog using the @a OK button, otherwise @c false."]
    pub fn ic4_gui_grabber_show_device_properties(
        hParent: IC4_WINDOW_HANDLE,
        pGrabber: *mut IC4_GRABBER,
        options: *const IC4_PROPERTY_DIALOG_OPTIONS,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Shows a dialog box allowing the user to configure the properties of a @ref IC4_PROPERTY_MAP.\n\n @param[in] hParent\t\tA parent window for the dialog\n @param[in] pPropertyMap\tA property map to configure\n @param[in] options\t\tAn options structure to customize the dialog's behavior\n\n @return @c true, if the user closed the dialog using the @a OK button, otherwise @c false."]
    pub fn ic4_gui_show_property_map(
        hParent: IC4_WINDOW_HANDLE,
        pPropertyMap: *mut IC4_PROPERTY_MAP,
        options: *const IC4_PROPERTY_DIALOG_OPTIONS,
    ) -> bool;
}
